# C++ ì•Œê³ ë¦¬ì¦˜/ìë£Œêµ¬ì¡° í•™ìŠµ ì»¤ë¦¬í˜ëŸ¼

## ğŸ“š í•™ìŠµ ë¡œë“œë§µ (ì´ 16ë‹¨ê³„)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          ğŸ¯ BEGINNER (ì…ë¬¸)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  STEP 0: C++ ê¸°ì´ˆ ë¬¸ë²• â† í˜„ì¬ ë‹¨ê³„                                          â”‚
â”‚  STEP 1: ì¡°ê±´ë¬¸ê³¼ ë°˜ë³µë¬¸                                                    â”‚
â”‚  STEP 2: ë°°ì—´ê³¼ ë¬¸ìì—´                                                      â”‚
â”‚  STEP 3: í•¨ìˆ˜ì™€ ì¬ê·€ ê¸°ì´ˆ                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          ğŸ“¦ INTERMEDIATE (ì¤‘ê¸‰)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  STEP 4: ê¸°ì´ˆ STL (vector, string, pair)                                   â”‚
â”‚  STEP 5: ì„ í˜• ìë£Œêµ¬ì¡° ì§ì ‘ êµ¬í˜„ (ìŠ¤íƒ, í, ë±, ì—°ê²°ë¦¬ìŠ¤íŠ¸)                   â”‚
â”‚  STEP 6: STL ì»¨í…Œì´ë„ˆ ì‹¬í™” (stack, queue, deque, list)                     â”‚
â”‚  STEP 7: ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ (ë²„ë¸”, ì„ íƒ, ì‚½ì…, í€µ, ë¨¸ì§€)                          â”‚
â”‚  STEP 8: íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ (ì´ë¶„ íƒìƒ‰, íŒŒë¼ë©”íŠ¸ë¦­)                               â”‚
â”‚  STEP 9: ë¹„íŠ¸ë§ˆìŠ¤í‚¹ ê¸°ì´ˆ                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                          ğŸš€ ADVANCED (ê³ ê¸‰)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  STEP 10: ê³ ê¸‰ STL (set, map, priority_queue, algorithm)                   â”‚
â”‚  STEP 11: ë¹„ì„ í˜• ìë£Œêµ¬ì¡° ì§ì ‘ êµ¬í˜„ (ì´ì§„íŠ¸ë¦¬, í™)                           â”‚
â”‚  STEP 12: ê·¸ë˜í”„ ê¸°ì´ˆ (BFS, DFS)                                           â”‚
â”‚  STEP 13: ìµœë‹¨ ê²½ë¡œ (ë‹¤ìµìŠ¤íŠ¸ë¼, í”Œë¡œì´ë“œ)                                   â”‚
â”‚  STEP 14: ë™ì  í”„ë¡œê·¸ë˜ë° (DP)                                              â”‚
â”‚  STEP 15: ë¹„íŠ¸ë§ˆìŠ¤í‚¹ ì‹¬í™” + DP                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ğŸ¯ BEGINNER (ì…ë¬¸) - ë¸Œë¡ ì¦ˆ í‹°ì–´

---

## STEP 0: C++ ê¸°ì´ˆ ë¬¸ë²• â¬…ï¸ **í˜„ì¬ ë‹¨ê³„**

### í•™ìŠµ ëª©í‘œ
- C++ í”„ë¡œê·¸ë¨ì˜ ê¸°ë³¸ êµ¬ì¡° ì´í•´
- í‘œì¤€ ì…ì¶œë ¥ ì‚¬ìš©ë²• ìŠµë“
- ê¸°ë³¸ ìë£Œí˜•ê³¼ ë³€ìˆ˜ ì´í•´

### í•µì‹¬ ê°œë…

#### 1. í”„ë¡œê·¸ë¨ ê¸°ë³¸ êµ¬ì¡°
```cpp
#include <iostream>  // ì…ì¶œë ¥ ë¼ì´ë¸ŒëŸ¬ë¦¬
using namespace std; // std ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì‚¬ìš©

int main() {
    // ì½”ë“œ ì‘ì„± ì˜ì—­
    return 0;  // í”„ë¡œê·¸ë¨ ì •ìƒ ì¢…ë£Œ
}
```

#### 2. ì¶œë ¥ (cout)
```cpp
cout << "Hello, World!" << endl;  // ë¬¸ìì—´ ì¶œë ¥
cout << 123 << endl;               // ìˆ«ì ì¶œë ¥
cout << "ìˆ«ì: " << 42 << endl;    // í˜¼í•© ì¶œë ¥
```

#### 3. ì…ë ¥ (cin)
```cpp
int num;
cin >> num;  // ì •ìˆ˜ ì…ë ¥ë°›ê¸°

string name;
cin >> name; // ë¬¸ìì—´ ì…ë ¥ë°›ê¸° (ê³µë°± ì „ê¹Œì§€)
```

#### 4. ê¸°ë³¸ ìë£Œí˜•
```cpp
int a = 10;        // ì •ìˆ˜ (-2^31 ~ 2^31-1)
long long b = 10;  // í° ì •ìˆ˜ (-2^63 ~ 2^63-1)
double c = 3.14;   // ì‹¤ìˆ˜
char d = 'A';      // ë¬¸ì
string e = "Hi";   // ë¬¸ìì—´
bool f = true;     // ì°¸/ê±°ì§“
```

### ì¶”ì²œ ë¬¸ì œ (ë¸Œë¡ ì¦ˆ 5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ | ì„¤ëª… |
|------|-----------|----------|------|------|
| 1 | 2557 | Hello World | êµ¬í˜„ | ê°€ì¥ ê¸°ì´ˆì ì¸ ì¶œë ¥ ë¬¸ì œ |
| 2 | 1000 | A+B | ì‚¬ì¹™ì—°ì‚° | ë‘ ìˆ˜ ì…ë ¥ë°›ì•„ ë”í•˜ê¸° |
| 3 | 1001 | A-B | ì‚¬ì¹™ì—°ì‚° | ë‘ ìˆ˜ ì…ë ¥ë°›ì•„ ë¹¼ê¸° |
| 4 | 10998 | AÃ—B | ì‚¬ì¹™ì—°ì‚° | ë‘ ìˆ˜ ì…ë ¥ë°›ì•„ ê³±í•˜ê¸° |
| 5 | 1008 | A/B | ì‚¬ì¹™ì—°ì‚° | ë‘ ìˆ˜ ì…ë ¥ë°›ì•„ ë‚˜ëˆ„ê¸° |
| 6 | 10869 | ì‚¬ì¹™ì—°ì‚° | ì‚¬ì¹™ì—°ì‚° | ì‚¬ì¹™ì—°ì‚° ì¢…í•© |
| 7 | 10926 | ??! | ë¬¸ìì—´ | ë¬¸ìì—´ ë’¤ì— ë¬¸ì ë¶™ì´ê¸° |
| 8 | 18108 | 1998ë…„ìƒì¸ ë‚´ê°€ íƒœí’ì´ë‹¤ | ì‚¬ì¹™ì—°ì‚° | ê°„ë‹¨í•œ ì—°ì‚° |
| 9 | 10171 | ê³ ì–‘ì´ | êµ¬í˜„ | ì—¬ëŸ¬ ì¤„ ì¶œë ¥ |
| 10 | 10172 | ê°œ | êµ¬í˜„ | íŠ¹ìˆ˜ë¬¸ì ì¶œë ¥ |

---

## STEP 1: ì¡°ê±´ë¬¸ê³¼ ë°˜ë³µë¬¸

### í•™ìŠµ ëª©í‘œ
- if-else, switch ì¡°ê±´ë¬¸ ë§ˆìŠ¤í„°
- for, while ë°˜ë³µë¬¸ ì´í•´
- ì¤‘ì²© ë°˜ë³µë¬¸ í™œìš©

### í•µì‹¬ ê°œë…

#### ì¡°ê±´ë¬¸
```cpp
if (ì¡°ê±´1) {
    // ì¡°ê±´1ì´ ì°¸ì¼ ë•Œ
} else if (ì¡°ê±´2) {
    // ì¡°ê±´2ê°€ ì°¸ì¼ ë•Œ
} else {
    // ëª¨ë“  ì¡°ê±´ì´ ê±°ì§“ì¼ ë•Œ
}
```

#### ë°˜ë³µë¬¸
```cpp
// for ë¬¸ - ë°˜ë³µ íšŸìˆ˜ê°€ ì •í•´ì§„ ê²½ìš°
for (int i = 0; i < n; i++) {
    // ë°˜ë³µ ë‚´ìš©
}

// while ë¬¸ - ì¡°ê±´ì´ ì°¸ì¸ ë™ì•ˆ ë°˜ë³µ
while (ì¡°ê±´) {
    // ë°˜ë³µ ë‚´ìš©
}
```

### ì¶”ì²œ ë¬¸ì œ (ë¸Œë¡ ì¦ˆ 4~5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 1330 | ë‘ ìˆ˜ ë¹„êµí•˜ê¸° | ì¡°ê±´ë¬¸ |
| 2 | 9498 | ì‹œí—˜ ì„±ì  | ì¡°ê±´ë¬¸ |
| 3 | 2753 | ìœ¤ë…„ | ì¡°ê±´ë¬¸ |
| 4 | 14681 | ì‚¬ë¶„ë©´ ê³ ë¥´ê¸° | ì¡°ê±´ë¬¸ |
| 5 | 2884 | ì•ŒëŒ ì‹œê³„ | ì¡°ê±´ë¬¸ |
| 6 | 2739 | êµ¬êµ¬ë‹¨ | ë°˜ë³µë¬¸ |
| 7 | 10950 | A+B - 3 | ë°˜ë³µë¬¸ |
| 8 | 8393 | í•© | ë°˜ë³µë¬¸ |
| 9 | 2438 | ë³„ ì°ê¸° - 1 | ë°˜ë³µë¬¸ |
| 10 | 2439 | ë³„ ì°ê¸° - 2 | ë°˜ë³µë¬¸ |

---

## STEP 2: ë°°ì—´ê³¼ ë¬¸ìì—´

### í•™ìŠµ ëª©í‘œ
- 1ì°¨ì›, 2ì°¨ì› ë°°ì—´ í™œìš©
- ë¬¸ìì—´ ì²˜ë¦¬ ê¸°ì´ˆ
- ë°°ì—´ ìˆœíšŒ ë° íƒìƒ‰

### í•µì‹¬ ê°œë…

#### ë°°ì—´
```cpp
int arr[5] = {1, 2, 3, 4, 5};      // 1ì°¨ì› ë°°ì—´
int matrix[3][3];                   // 2ì°¨ì› ë°°ì—´

// ë°°ì—´ ìˆœíšŒ
for (int i = 0; i < 5; i++) {
    cout << arr[i] << " ";
}
```

#### ë¬¸ìì—´
```cpp
string s = "hello";
cout << s.length() << endl;  // ê¸¸ì´: 5
cout << s[0] << endl;        // ì²« ë¬¸ì: 'h'
s += " world";               // ë¬¸ìì—´ ì—°ê²°
```

### ì¶”ì²œ ë¬¸ì œ (ë¸Œë¡ ì¦ˆ 3~4)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 10818 | ìµœì†Œ, ìµœëŒ€ | ë°°ì—´ |
| 2 | 2562 | ìµœëŒ“ê°’ | ë°°ì—´ |
| 3 | 10871 | Xë³´ë‹¤ ì‘ì€ ìˆ˜ | ë°°ì—´ |
| 4 | 10807 | ê°œìˆ˜ ì„¸ê¸° | ë°°ì—´ |
| 5 | 11720 | ìˆ«ìì˜ í•© | ë¬¸ìì—´ |
| 6 | 10809 | ì•ŒíŒŒë²³ ì°¾ê¸° | ë¬¸ìì—´ |
| 7 | 2675 | ë¬¸ìì—´ ë°˜ë³µ | ë¬¸ìì—´ |
| 8 | 1152 | ë‹¨ì–´ì˜ ê°œìˆ˜ | ë¬¸ìì—´ |
| 9 | 2566 | ìµœëŒ“ê°’ | 2ì°¨ì› ë°°ì—´ |
| 10 | 2563 | ìƒ‰ì¢…ì´ | 2ì°¨ì› ë°°ì—´ |

---

## STEP 3: í•¨ìˆ˜ì™€ ì¬ê·€ ê¸°ì´ˆ

### í•™ìŠµ ëª©í‘œ
- í•¨ìˆ˜ ì •ì˜ì™€ í˜¸ì¶œ
- ê°’ ì „ë‹¬ê³¼ ì°¸ì¡° ì „ë‹¬
- ì¬ê·€ í•¨ìˆ˜ì˜ ê¸°ë³¸ ì›ë¦¬

### í•µì‹¬ ê°œë…

#### í•¨ìˆ˜ ì •ì˜
```cpp
// ë°˜í™˜ê°’ì´ ìˆëŠ” í•¨ìˆ˜
int add(int a, int b) {
    return a + b;
}

// ì°¸ì¡° ì „ë‹¬
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

#### ì¬ê·€ í•¨ìˆ˜
```cpp
// íŒ©í† ë¦¬ì–¼ (n!)
int factorial(int n) {
    if (n <= 1) return 1;       // ê¸°ì € ì¡°ê±´
    return n * factorial(n - 1); // ì¬ê·€ í˜¸ì¶œ
}

// í”¼ë³´ë‚˜ì¹˜
int fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

### ì¶”ì²œ ë¬¸ì œ (ë¸Œë¡ ì¦ˆ 2~3)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 15596 | ì •ìˆ˜ Nê°œì˜ í•© | í•¨ìˆ˜ |
| 2 | 4673 | ì…€í”„ ë„˜ë²„ | í•¨ìˆ˜ |
| 3 | 1065 | í•œìˆ˜ | í•¨ìˆ˜ |
| 4 | 10872 | íŒ©í† ë¦¬ì–¼ | ì¬ê·€ |
| 5 | 10870 | í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 5 | ì¬ê·€ |
| 6 | 2447 | ë³„ ì°ê¸° - 10 | ì¬ê·€ |
| 7 | 11729 | í•˜ë…¸ì´ íƒ‘ ì´ë™ ìˆœì„œ | ì¬ê·€ |
| 8 | 17478 | ì¬ê·€í•¨ìˆ˜ê°€ ë­”ê°€ìš”? | ì¬ê·€ |

---

# ğŸ“¦ INTERMEDIATE (ì¤‘ê¸‰) - ì‹¤ë²„ í‹°ì–´

---

## STEP 4: ê¸°ì´ˆ STL

### í•™ìŠµ ëª©í‘œ
- vector ì»¨í…Œì´ë„ˆ í™œìš©
- pairì™€ tuple ì‚¬ìš©ë²•
- ê¸°ë³¸ algorithm í•¨ìˆ˜ë“¤

### í•µì‹¬ ê°œë…

#### vector
```cpp
#include <vector>

vector<int> v;              // ë¹ˆ ë²¡í„° ìƒì„±
vector<int> v2(10, 0);      // í¬ê¸° 10, 0ìœ¼ë¡œ ì´ˆê¸°í™”

v.push_back(1);             // ëì— ì¶”ê°€
v.pop_back();               // ëì—ì„œ ì œê±°
v.size();                   // í¬ê¸°
v[0];                       // ì¸ë±ìŠ¤ ì ‘ê·¼
v.front();                  // ì²« ìš”ì†Œ
v.back();                   // ë§ˆì§€ë§‰ ìš”ì†Œ
```

#### pair
```cpp
#include <utility>

pair<int, int> p = {1, 2};
p.first;   // 1
p.second;  // 2

// pair ë¹„êµ: first ë¨¼ì €, ê°™ìœ¼ë©´ second
pair<int, int> a = {1, 3};
pair<int, int> b = {1, 2};
// b < a (second ë¹„êµì—ì„œ 2 < 3)
```

#### ê¸°ë³¸ algorithm
```cpp
#include <algorithm>

vector<int> v = {3, 1, 4, 1, 5};
sort(v.begin(), v.end());            // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
sort(v.begin(), v.end(), greater<int>()); // ë‚´ë¦¼ì°¨ìˆœ

int maxVal = *max_element(v.begin(), v.end());
int minVal = *min_element(v.begin(), v.end());
```

### ì¶”ì²œ ë¬¸ì œ (ì‹¤ë²„ 5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 10828 | ìŠ¤íƒ | STL ì—°ìŠµ |
| 2 | 10845 | í | STL ì—°ìŠµ |
| 3 | 11650 | ì¢Œí‘œ ì •ë ¬í•˜ê¸° | pair, sort |
| 4 | 11651 | ì¢Œí‘œ ì •ë ¬í•˜ê¸° 2 | pair, sort |
| 5 | 10814 | ë‚˜ì´ìˆœ ì •ë ¬ | ì•ˆì • ì •ë ¬ |

---

## STEP 5: ì„ í˜• ìë£Œêµ¬ì¡° ì§ì ‘ êµ¬í˜„ â­

### í•™ìŠµ ëª©í‘œ
- STL ì—†ì´ ìë£Œêµ¬ì¡° ì§ì ‘ êµ¬í˜„
- structì™€ ì „ì—­ ë°°ì—´ì„ í™œìš©í•œ êµ¬í˜„ (ëŒ€íšŒ ìŠ¤íƒ€ì¼)
- í¬ì¸í„° ê¸°ë°˜ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì´í•´

> ğŸ’¡ **ì™œ structë¥¼ ì‚¬ìš©í•˜ë‚˜ìš”?**
> - C++ì—ì„œ `struct`ì™€ `class`ì˜ ìœ ì¼í•œ ì°¨ì´ëŠ” ê¸°ë³¸ ì ‘ê·¼ ì œí•œìì…ë‹ˆë‹¤.
> - `struct`: ê¸°ë³¸ì´ `public` (ë©¤ë²„ì— ë°”ë¡œ ì ‘ê·¼ ê°€ëŠ¥)
> - `class`: ê¸°ë³¸ì´ `private` (getter/setter í•„ìš”)
> - ì•Œê³ ë¦¬ì¦˜ ëŒ€íšŒì—ì„œëŠ” **ê°„ê²°í•¨**ì´ ì¤‘ìš”í•˜ë¯€ë¡œ `struct`ë¥¼ ì£¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.

### 5-1. ìŠ¤íƒ (Stack) ì§ì ‘ êµ¬í˜„

```cpp
// ë°©ë²• 1: ì „ì—­ ë°°ì—´ + ë³€ìˆ˜ (ê°€ì¥ ê°„ë‹¨, ëŒ€íšŒì—ì„œ ê°€ì¥ ë§ì´ ì‚¬ìš©)
int stk[10000];
int top_idx = -1;

void push(int x) { stk[++top_idx] = x; }
int pop() { return stk[top_idx--]; }
int top() { return stk[top_idx]; }
bool empty() { return top_idx == -1; }
int size() { return top_idx + 1; }
```

```cpp
// ë°©ë²• 2: structë¡œ ìº¡ìŠí™” (ì—¬ëŸ¬ ìŠ¤íƒì´ í•„ìš”í•  ë•Œ)
struct Stack {
    int data[10000];
    int top_idx = -1;
    
    void push(int x) { data[++top_idx] = x; }
    int pop() { return data[top_idx--]; }
    int top() { return data[top_idx]; }
    bool empty() { return top_idx == -1; }
    int size() { return top_idx + 1; }
};

// ì‚¬ìš©ë²•
Stack stk;
stk.push(10);
cout << stk.top();  // 10
```

### 5-2. í (Queue) ì§ì ‘ êµ¬í˜„

```cpp
// ë°©ë²• 1: ì „ì—­ ë°°ì—´ + ë³€ìˆ˜
int que[10001];
int front_idx = 0, back_idx = 0;

void push(int x) { que[back_idx++] = x; }
int pop() { return que[front_idx++]; }
int front() { return que[front_idx]; }
int back() { return que[back_idx - 1]; }
bool empty() { return front_idx == back_idx; }
int size() { return back_idx - front_idx; }
```

```cpp
// ë°©ë²• 2: structë¡œ ìº¡ìŠí™”
struct Queue {
    int data[10001];
    int front_idx = 0, back_idx = 0;
    
    void push(int x) { data[back_idx++] = x; }
    int pop() { return data[front_idx++]; }
    int front() { return data[front_idx]; }
    int back() { return data[back_idx - 1]; }
    bool empty() { return front_idx == back_idx; }
    int size() { return back_idx - front_idx; }
};
```

### 5-3. ë± (Deque) ì§ì ‘ êµ¬í˜„

```cpp
// ë°©ë²• 1: ì „ì—­ ë°°ì—´ (ì¤‘ê°„ì—ì„œ ì‹œì‘)
int dq[20001];
int front_idx = 10000, back_idx = 10000;

void push_front(int x) { dq[--front_idx] = x; }
void push_back(int x) { dq[back_idx++] = x; }
int pop_front() { return dq[front_idx++]; }
int pop_back() { return dq[--back_idx]; }
int front() { return dq[front_idx]; }
int back() { return dq[back_idx - 1]; }
bool empty() { return front_idx == back_idx; }
int size() { return back_idx - front_idx; }
```

```cpp
// ë°©ë²• 2: structë¡œ ìº¡ìŠí™”
struct Deque {
    int data[20001];
    int front_idx = 10000, back_idx = 10000;
    
    void push_front(int x) { data[--front_idx] = x; }
    void push_back(int x) { data[back_idx++] = x; }
    int pop_front() { return data[front_idx++]; }
    int pop_back() { return data[--back_idx]; }
    int front() { return data[front_idx]; }
    int back() { return data[back_idx - 1]; }
    bool empty() { return front_idx == back_idx; }
    int size() { return back_idx - front_idx; }
};
```

### 5-4. ì—°ê²° ë¦¬ìŠ¤íŠ¸ (Linked List) ì§ì ‘ êµ¬í˜„

```cpp
// ë…¸ë“œ êµ¬ì¡°ì²´ ì •ì˜
struct Node {
    int data;
    Node* next;
};

// ì „ì—­ ë³€ìˆ˜
Node* head = nullptr;
int list_size = 0;

// ë§¨ ì•ì— ì‚½ì…
void push_front(int x) {
    Node* new_node = new Node();
    new_node->data = x;
    new_node->next = head;
    head = new_node;
    list_size++;
}

// ë§¨ ì• ì‚­ì œ
int pop_front() {
    if (!head) return -1;
    Node* temp = head;
    int val = temp->data;
    head = head->next;
    delete temp;
    list_size--;
    return val;
}

// íŠ¹ì • ìœ„ì¹˜ì— ì‚½ì…
void insert(int idx, int x) {
    if (idx == 0) {
        push_front(x);
        return;
    }
    Node* cur = head;
    for (int i = 0; i < idx - 1 && cur; i++) {
        cur = cur->next;
    }
    if (cur) {
        Node* new_node = new Node();
        new_node->data = x;
        new_node->next = cur->next;
        cur->next = new_node;
        list_size++;
    }
}

// íŠ¹ì • ìœ„ì¹˜ ì‚­ì œ
void erase(int idx) {
    if (idx == 0) {
        pop_front();
        return;
    }
    Node* cur = head;
    for (int i = 0; i < idx - 1 && cur; i++) {
        cur = cur->next;
    }
    if (cur && cur->next) {
        Node* temp = cur->next;
        cur->next = temp->next;
        delete temp;
        list_size--;
    }
}

int size() { return list_size; }
bool empty() { return list_size == 0; }
```

### 5-5. ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (Doubly Linked List)

```cpp
// ë…¸ë“œ êµ¬ì¡°ì²´ ì •ì˜
struct DNode {
    int data;
    DNode* prev;
    DNode* next;
};

// ì „ì—­ ë³€ìˆ˜
DNode* head = nullptr;
DNode* tail = nullptr;
int list_size = 0;

// ë§¨ ì•ì— ì‚½ì…
void push_front(int x) {
    DNode* new_node = new DNode();
    new_node->data = x;
    new_node->prev = nullptr;
    new_node->next = head;
    
    if (head) head->prev = new_node;
    else tail = new_node;
    
    head = new_node;
    list_size++;
}

// ë§¨ ë’¤ì— ì‚½ì…
void push_back(int x) {
    DNode* new_node = new DNode();
    new_node->data = x;
    new_node->next = nullptr;
    new_node->prev = tail;
    
    if (tail) tail->next = new_node;
    else head = new_node;
    
    tail = new_node;
    list_size++;
}

// ë§¨ ì• ì‚­ì œ
int pop_front() {
    if (!head) return -1;
    DNode* temp = head;
    int val = temp->data;
    head = head->next;
    
    if (head) head->prev = nullptr;
    else tail = nullptr;
    
    delete temp;
    list_size--;
    return val;
}

// ë§¨ ë’¤ ì‚­ì œ
int pop_back() {
    if (!tail) return -1;
    DNode* temp = tail;
    int val = temp->data;
    tail = tail->prev;
    
    if (tail) tail->next = nullptr;
    else head = nullptr;
    
    delete temp;
    list_size--;
    return val;
}

int size() { return list_size; }
bool empty() { return list_size == 0; }
```

### 5-6. ë°°ì—´ ê¸°ë°˜ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (ì •ì  í• ë‹¹)

> ğŸ’¡ **ë™ì  í• ë‹¹ ì—†ì´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ êµ¬í˜„í•˜ê¸°**
> ëŒ€íšŒì—ì„œ `new`/`delete` ì—†ì´ ë°°ì—´ë¡œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

```cpp
const int MAX = 100001;

struct Node {
    int data;
    int prev, next;  // ì¸ë±ìŠ¤ë¡œ ì—°ê²°
} node[MAX];

int head = -1, tail = -1;
int node_cnt = 0;

// ìƒˆ ë…¸ë“œ í• ë‹¹
int alloc(int x) {
    node[node_cnt].data = x;
    node[node_cnt].prev = -1;
    node[node_cnt].next = -1;
    return node_cnt++;
}

// ë§¨ ë’¤ì— ì‚½ì…
void push_back(int x) {
    int idx = alloc(x);
    if (tail == -1) {
        head = tail = idx;
    } else {
        node[tail].next = idx;
        node[idx].prev = tail;
        tail = idx;
    }
}

// íŠ¹ì • ë…¸ë“œ ë’¤ì— ì‚½ì…
void insert_after(int target, int x) {
    int idx = alloc(x);
    node[idx].prev = target;
    node[idx].next = node[target].next;
    
    if (node[target].next != -1) {
        node[node[target].next].prev = idx;
    } else {
        tail = idx;
    }
    node[target].next = idx;
}

// íŠ¹ì • ë…¸ë“œ ì‚­ì œ
void erase(int idx) {
    if (node[idx].prev != -1) {
        node[node[idx].prev].next = node[idx].next;
    } else {
        head = node[idx].next;
    }
    
    if (node[idx].next != -1) {
        node[node[idx].next].prev = node[idx].prev;
    } else {
        tail = node[idx].prev;
    }
}
```

### ì¶”ì²œ ë¬¸ì œ (ìë£Œêµ¬ì¡° ì§ì ‘ êµ¬í˜„)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | êµ¬í˜„ ëŒ€ìƒ |
|------|-----------|----------|----------|
| 1 | 10828 | ìŠ¤íƒ | ìŠ¤íƒ êµ¬í˜„ |
| 2 | 10845 | í | í êµ¬í˜„ |
| 3 | 10866 | ë± | ë± êµ¬í˜„ |
| 4 | 1158 | ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ | ì—°ê²°ë¦¬ìŠ¤íŠ¸/í |
| 5 | 5397 | í‚¤ë¡œê±° | ì—°ê²°ë¦¬ìŠ¤íŠ¸/ìŠ¤íƒ |
| 6 | 1406 | ì—ë””í„° | ì—°ê²°ë¦¬ìŠ¤íŠ¸/ìŠ¤íƒ |

---

## STEP 6: STL ì»¨í…Œì´ë„ˆ ì‹¬í™”

### í•™ìŠµ ëª©í‘œ
- stack, queue, deque STL í™œìš©
- list ì»¨í…Œì´ë„ˆ ì´í•´
- ë°˜ë³µì(iterator) í™œìš©

### í•µì‹¬ ê°œë…

```cpp
#include <stack>
#include <queue>
#include <deque>
#include <list>

// ìŠ¤íƒ
stack<int> st;
st.push(1); st.pop(); st.top(); st.empty(); st.size();

// í
queue<int> q;
q.push(1); q.pop(); q.front(); q.back(); q.empty();

// ë±
deque<int> dq;
dq.push_front(1); dq.push_back(2);
dq.pop_front(); dq.pop_back();
dq.front(); dq.back();

// ë¦¬ìŠ¤íŠ¸ (ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸)
list<int> lst;
lst.push_front(1); lst.push_back(2);
auto it = lst.begin();
lst.insert(it, 3);  // ë°˜ë³µì ìœ„ì¹˜ì— ì‚½ì…
lst.erase(it);      // ë°˜ë³µì ìœ„ì¹˜ ì‚­ì œ
```

### ì¶”ì²œ ë¬¸ì œ (ì‹¤ë²„ 4~5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 9012 | ê´„í˜¸ | ìŠ¤íƒ |
| 2 | 4949 | ê· í˜•ì¡íŒ ì„¸ìƒ | ìŠ¤íƒ |
| 3 | 1874 | ìŠ¤íƒ ìˆ˜ì—´ | ìŠ¤íƒ |
| 4 | 2164 | ì¹´ë“œ2 | í |
| 5 | 11866 | ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ 0 | í |
| 6 | 5430 | AC | ë± |

---

## STEP 7: ì •ë ¬ ì•Œê³ ë¦¬ì¦˜

### í•™ìŠµ ëª©í‘œ
- O(nÂ²) ì •ë ¬: ë²„ë¸”, ì„ íƒ, ì‚½ì…
- O(n log n) ì •ë ¬: í€µ, ë¨¸ì§€
- ì •ë ¬ì˜ ì•ˆì •ì„± ì´í•´

### í•µì‹¬ ê°œë…

#### ë²„ë¸” ì •ë ¬ O(nÂ²)
```cpp
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```

#### í€µ ì •ë ¬ O(n log n)
```cpp
void quickSort(int arr[], int left, int right) {
    if (left >= right) return;
    
    int pivot = arr[(left + right) / 2];
    int i = left, j = right;
    
    while (i <= j) {
        while (arr[i] < pivot) i++;
        while (arr[j] > pivot) j--;
        if (i <= j) {
            swap(arr[i], arr[j]);
            i++; j--;
        }
    }
    
    quickSort(arr, left, j);
    quickSort(arr, i, right);
}
```

#### ë³‘í•© ì •ë ¬ O(n log n)
```cpp
void merge(int arr[], int left, int mid, int right) {
    vector<int> temp;
    int i = left, j = mid + 1;
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) temp.push_back(arr[i++]);
        else temp.push_back(arr[j++]);
    }
    while (i <= mid) temp.push_back(arr[i++]);
    while (j <= right) temp.push_back(arr[j++]);
    
    for (int k = left; k <= right; k++) {
        arr[k] = temp[k - left];
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left >= right) return;
    
    int mid = (left + right) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```

### ì¶”ì²œ ë¬¸ì œ (ì‹¤ë²„ 3~5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 2750 | ìˆ˜ ì •ë ¬í•˜ê¸° | ì •ë ¬ ê¸°ì´ˆ |
| 2 | 2751 | ìˆ˜ ì •ë ¬í•˜ê¸° 2 | O(n log n) ì •ë ¬ |
| 3 | 10989 | ìˆ˜ ì •ë ¬í•˜ê¸° 3 | ì¹´ìš´íŒ… ì •ë ¬ |
| 4 | 1427 | ì†ŒíŠ¸ì¸ì‚¬ì´ë“œ | ì •ë ¬ |
| 5 | 11650 | ì¢Œí‘œ ì •ë ¬í•˜ê¸° | ë‹¤ì¤‘ ì¡°ê±´ ì •ë ¬ |
| 6 | 10814 | ë‚˜ì´ìˆœ ì •ë ¬ | ì•ˆì • ì •ë ¬ |

---

## STEP 8: íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜

### í•™ìŠµ ëª©í‘œ
- ì´ë¶„ íƒìƒ‰ ì›ë¦¬ì™€ êµ¬í˜„
- lower_bound, upper_bound
- íŒŒë¼ë©”íŠ¸ë¦­ ì„œì¹˜

### í•µì‹¬ ê°œë…

#### ì´ë¶„ íƒìƒ‰
```cpp
// ì •ë ¬ëœ ë°°ì—´ì—ì„œ target ì°¾ê¸°
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    
    return -1;  // ì°¾ì§€ ëª»í•¨
}
```

#### STL ì´ë¶„ íƒìƒ‰
```cpp
#include <algorithm>

vector<int> v = {1, 2, 3, 4, 5};
binary_search(v.begin(), v.end(), 3);  // true/false

auto lb = lower_bound(v.begin(), v.end(), 3);  // 3 ì´ìƒ ì²« ìœ„ì¹˜
auto ub = upper_bound(v.begin(), v.end(), 3);  // 3 ì´ˆê³¼ ì²« ìœ„ì¹˜
```

### ì¶”ì²œ ë¬¸ì œ (ì‹¤ë²„ 2~4)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 1920 | ìˆ˜ ì°¾ê¸° | ì´ë¶„ íƒìƒ‰ ê¸°ì´ˆ |
| 2 | 10816 | ìˆ«ì ì¹´ë“œ 2 | lower/upper_bound |
| 3 | 1654 | ëœì„  ìë¥´ê¸° | íŒŒë¼ë©”íŠ¸ë¦­ |
| 4 | 2805 | ë‚˜ë¬´ ìë¥´ê¸° | íŒŒë¼ë©”íŠ¸ë¦­ |
| 5 | 2110 | ê³µìœ ê¸° ì„¤ì¹˜ | íŒŒë¼ë©”íŠ¸ë¦­ |

---

## STEP 9: ë¹„íŠ¸ë§ˆìŠ¤í‚¹ ê¸°ì´ˆ â­

### í•™ìŠµ ëª©í‘œ
- ë¹„íŠ¸ ì—°ì‚°ì ì´í•´
- ì§‘í•©ì„ ë¹„íŠ¸ë¡œ í‘œí˜„
- ë¹„íŠ¸ë§ˆìŠ¤í¬ë¡œ ìƒíƒœ ê´€ë¦¬

### í•µì‹¬ ê°œë…

#### ë¹„íŠ¸ ì—°ì‚°ì
```cpp
// ë¹„íŠ¸ ì—°ì‚°ì ì¢…ë¥˜
a & b   // AND: ë‘˜ ë‹¤ 1ì´ë©´ 1
a | b   // OR: í•˜ë‚˜ë¼ë„ 1ì´ë©´ 1
a ^ b   // XOR: ì„œë¡œ ë‹¤ë¥´ë©´ 1
~a      // NOT: ë¹„íŠ¸ ë°˜ì „
a << n  // ì™¼ìª½ ì‹œí”„íŠ¸: 2^n ê³±í•˜ê¸°
a >> n  // ì˜¤ë¥¸ìª½ ì‹œí”„íŠ¸: 2^n ë‚˜ëˆ„ê¸°
```

#### ì§‘í•© í‘œí˜„ (0~N-1 ì›ì†Œ)
```cpp
int S = 0;  // ê³µì§‘í•©

// ië²ˆì§¸ ì›ì†Œ ì¶”ê°€
S |= (1 << i);

// ië²ˆì§¸ ì›ì†Œ ì œê±°
S &= ~(1 << i);

// ië²ˆì§¸ ì›ì†Œ í¬í•¨ ì—¬ë¶€
bool has = (S >> i) & 1;
// ë˜ëŠ”
bool has = S & (1 << i);

// ië²ˆì§¸ ì›ì†Œ í† ê¸€ (ìˆìœ¼ë©´ ì œê±°, ì—†ìœ¼ë©´ ì¶”ê°€)
S ^= (1 << i);

// ì§‘í•© í¬ê¸° (ì›ì†Œ ê°œìˆ˜)
int count = __builtin_popcount(S);
```

#### ëª¨ë“  ë¶€ë¶„ì§‘í•© ìˆœíšŒ
```cpp
int n = 4;  // ì›ì†Œ ê°œìˆ˜
int full = (1 << n) - 1;  // ì „ì²´ ì§‘í•© {0,1,2,3}

// ëª¨ë“  ë¶€ë¶„ì§‘í•© ìˆœíšŒ
for (int S = 0; S <= full; S++) {
    // SëŠ” ê° ë¶€ë¶„ì§‘í•©ì„ ë¹„íŠ¸ë¡œ í‘œí˜„
    for (int i = 0; i < n; i++) {
        if (S & (1 << i)) {
            cout << i << " ";  // Sì— í¬í•¨ëœ ì›ì†Œ ì¶œë ¥
        }
    }
    cout << endl;
}

// íŠ¹ì • ì§‘í•© Sì˜ ëª¨ë“  ë¶€ë¶„ì§‘í•© ìˆœíšŒ
for (int subset = S; subset > 0; subset = (subset - 1) & S) {
    // subset ì²˜ë¦¬
}
```

### ì¶”ì²œ ë¬¸ì œ (ì‹¤ë²„ 3~5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 11723 | ì§‘í•© | ë¹„íŠ¸ë§ˆìŠ¤í¬ ê¸°ì´ˆ |
| 2 | 1182 | ë¶€ë¶„ìˆ˜ì—´ì˜ í•© | ë¹„íŠ¸ë§ˆìŠ¤í¬ ì™„ì „íƒìƒ‰ |
| 3 | 14889 | ìŠ¤íƒ€íŠ¸ì™€ ë§í¬ | ë¹„íŠ¸ë§ˆìŠ¤í¬ |
| 4 | 14391 | ì¢…ì´ ì¡°ê° | ë¹„íŠ¸ë§ˆìŠ¤í¬ |

---

# ğŸš€ ADVANCED (ê³ ê¸‰) - ê³¨ë“œ í‹°ì–´

---

## STEP 10: ê³ ê¸‰ STL â­

### í•™ìŠµ ëª©í‘œ
- set, map ì»¨í…Œì´ë„ˆ í™œìš©
- priority_queue (í™)
- algorithm ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‹¬í™”

### í•µì‹¬ ê°œë…

#### set (ì •ë ¬ëœ ì§‘í•©, ì¤‘ë³µ ë¶ˆê°€)
```cpp
#include <set>

set<int> s;
s.insert(3);          // ì‚½ì… O(log n)
s.erase(3);           // ì‚­ì œ O(log n)
s.count(3);           // í¬í•¨ ì—¬ë¶€ (0 or 1)
s.find(3) != s.end(); // ì°¾ê¸°

// ì •ë ¬ëœ ìˆœì„œë¡œ ìˆœíšŒ
for (int x : s) cout << x << " ";

// multiset - ì¤‘ë³µ í—ˆìš©
multiset<int> ms;
```

#### map (í‚¤-ê°’ ìŒ, ì •ë ¬ë¨)
```cpp
#include <map>

map<string, int> m;
m["apple"] = 5;       // ì‚½ì…/ìˆ˜ì • O(log n)
m["banana"] = 3;
m.count("apple");     // í‚¤ ì¡´ì¬ ì—¬ë¶€
m.erase("apple");     // ì‚­ì œ

for (auto& [key, val] : m) {
    cout << key << ": " << val << endl;
}

// unordered_map - í•´ì‹œ ê¸°ë°˜ O(1)
#include <unordered_map>
unordered_map<string, int> um;
```

#### priority_queue (ìµœëŒ€ í™)
```cpp
#include <queue>

priority_queue<int> pq;  // ìµœëŒ€ í™
pq.push(3);
pq.push(1);
pq.push(4);
pq.top();   // 4 (ìµœëŒ“ê°’)
pq.pop();   // 4 ì œê±°

// ìµœì†Œ í™
priority_queue<int, vector<int>, greater<int>> minPq;

// ì»¤ìŠ¤í…€ ë¹„êµ
struct Compare {
    bool operator()(int a, int b) {
        return a > b;  // ìµœì†Œ í™
    }
};
priority_queue<int, vector<int>, Compare> customPq;
```

#### algorithm ì‹¬í™”
```cpp
#include <algorithm>

// next_permutation - ë‹¤ìŒ ìˆœì—´
vector<int> v = {1, 2, 3};
do {
    // í˜„ì¬ ìˆœì—´ ì²˜ë¦¬
} while (next_permutation(v.begin(), v.end()));

// unique - ì—°ì† ì¤‘ë³µ ì œê±° (ì •ë ¬ í•„ìš”)
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());

// nth_element - kë²ˆì§¸ ì›ì†Œ
nth_element(v.begin(), v.begin() + k, v.end());
// v[k]ê°€ kë²ˆì§¸ë¡œ ì‘ì€ ì›ì†Œ

// partial_sort - ìƒìœ„ kê°œë§Œ ì •ë ¬
partial_sort(v.begin(), v.begin() + k, v.end());
```

### ì¶”ì²œ ë¬¸ì œ (ê³¨ë“œ 5~ì‹¤ë²„ 1)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 7785 | íšŒì‚¬ì— ìˆëŠ” ì‚¬ëŒ | set/map |
| 2 | 1764 | ë“£ë³´ì¡ | set |
| 3 | 1927 | ìµœì†Œ í™ | priority_queue |
| 4 | 11279 | ìµœëŒ€ í™ | priority_queue |
| 5 | 11286 | ì ˆëŒ“ê°’ í™ | priority_queue |
| 6 | 10972 | ë‹¤ìŒ ìˆœì—´ | permutation |
| 7 | 9375 | íŒ¨ì…˜ì™• ì‹ í•´ë¹ˆ | map |

---

## STEP 11: ë¹„ì„ í˜• ìë£Œêµ¬ì¡° ì§ì ‘ êµ¬í˜„ â­

### í•™ìŠµ ëª©í‘œ
- í™ ì§ì ‘ êµ¬í˜„ (ë°°ì—´ ê¸°ë°˜)
- ì´ì§„ íŠ¸ë¦¬ êµ¬í˜„
- íŠ¸ë¦¬ ìˆœíšŒ (ì „ìœ„, ì¤‘ìœ„, í›„ìœ„)

### 11-1. í™ (Heap) ì§ì ‘ êµ¬í˜„

> ğŸ’¡ **í™ì˜ íŠ¹ì„±**
> - ì™„ì „ ì´ì§„ íŠ¸ë¦¬ í˜•íƒœ
> - ìµœì†Œ í™: ë¶€ëª¨ â‰¤ ìì‹
> - ìµœëŒ€ í™: ë¶€ëª¨ â‰¥ ìì‹
> - ë°°ì—´ë¡œ êµ¬í˜„ ê°€ëŠ¥ (ì¸ë±ìŠ¤ ê´€ê³„ í™œìš©)

```cpp
// ë°°ì—´ ê¸°ë°˜ ìµœì†Œ í™
const int MAX = 100001;
int heap[MAX];
int heap_size = 0;

// ë¶€ëª¨/ìì‹ ì¸ë±ìŠ¤ ê³„ì‚° (1-indexed)
int parent(int i) { return i / 2; }
int left_child(int i) { return i * 2; }
int right_child(int i) { return i * 2 + 1; }

// ìœ„ë¡œ ì˜¬ë¦¬ê¸° (ì‚½ì… ì‹œ)
void heapify_up(int i) {
    while (i > 1 && heap[parent(i)] > heap[i]) {
        swap(heap[parent(i)], heap[i]);
        i = parent(i);
    }
}

// ì•„ë˜ë¡œ ë‚´ë¦¬ê¸° (ì‚­ì œ ì‹œ)
void heapify_down(int i) {
    int smallest = i;
    int left = left_child(i);
    int right = right_child(i);
    
    if (left <= heap_size && heap[left] < heap[smallest])
        smallest = left;
    if (right <= heap_size && heap[right] < heap[smallest])
        smallest = right;
    
    if (smallest != i) {
        swap(heap[i], heap[smallest]);
        heapify_down(smallest);
    }
}

// ì‚½ì…
void push(int x) {
    heap[++heap_size] = x;
    heapify_up(heap_size);
}

// ìµœì†Ÿê°’ ì‚­ì œ ë° ë°˜í™˜
int pop() {
    if (heap_size == 0) return -1;
    int top = heap[1];
    heap[1] = heap[heap_size--];
    heapify_down(1);
    return top;
}

// ìµœì†Ÿê°’ í™•ì¸
int top() {
    return heap_size > 0 ? heap[1] : -1;
}

bool empty() { return heap_size == 0; }
int size() { return heap_size; }
```

```cpp
// structë¡œ ìº¡ìŠí™” (ì—¬ëŸ¬ í™ì´ í•„ìš”í•  ë•Œ)
struct MinHeap {
    int data[MAX];
    int sz = 0;
    
    int parent(int i) { return i / 2; }
    int left(int i) { return i * 2; }
    int right(int i) { return i * 2 + 1; }
    
    void up(int i) {
        while (i > 1 && data[parent(i)] > data[i]) {
            swap(data[parent(i)], data[i]);
            i = parent(i);
        }
    }
    
    void down(int i) {
        int small = i;
        if (left(i) <= sz && data[left(i)] < data[small]) small = left(i);
        if (right(i) <= sz && data[right(i)] < data[small]) small = right(i);
        if (small != i) {
            swap(data[i], data[small]);
            down(small);
        }
    }
    
    void push(int x) { data[++sz] = x; up(sz); }
    int pop() { int t = data[1]; data[1] = data[sz--]; down(1); return t; }
    int top() { return data[1]; }
    bool empty() { return sz == 0; }
};
```

### 11-2. ì´ì§„ íŠ¸ë¦¬ (Binary Tree) ì§ì ‘ êµ¬í˜„

```cpp
// í¬ì¸í„° ê¸°ë°˜ ì´ì§„ íŠ¸ë¦¬
struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;
};

// ë…¸ë“œ ìƒì„±
TreeNode* create_node(int x) {
    TreeNode* node = new TreeNode();
    node->data = x;
    node->left = nullptr;
    node->right = nullptr;
    return node;
}

// ì „ìœ„ ìˆœíšŒ (Pre-order): ë£¨íŠ¸ â†’ ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½
void preorder(TreeNode* node) {
    if (!node) return;
    cout << node->data << " ";  // ë£¨íŠ¸ ë°©ë¬¸
    preorder(node->left);
    preorder(node->right);
}

// ì¤‘ìœ„ ìˆœíšŒ (In-order): ì™¼ìª½ â†’ ë£¨íŠ¸ â†’ ì˜¤ë¥¸ìª½
void inorder(TreeNode* node) {
    if (!node) return;
    inorder(node->left);
    cout << node->data << " ";  // ë£¨íŠ¸ ë°©ë¬¸
    inorder(node->right);
}

// í›„ìœ„ ìˆœíšŒ (Post-order): ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½ â†’ ë£¨íŠ¸
void postorder(TreeNode* node) {
    if (!node) return;
    postorder(node->left);
    postorder(node->right);
    cout << node->data << " ";  // ë£¨íŠ¸ ë°©ë¬¸
}

// ì‚¬ìš© ì˜ˆì‹œ
int main() {
    TreeNode* root = create_node(1);
    root->left = create_node(2);
    root->right = create_node(3);
    root->left->left = create_node(4);
    root->left->right = create_node(5);
    
    //       1
    //      / \
    //     2   3
    //    / \
    //   4   5
    
    preorder(root);   // 1 2 4 5 3
    inorder(root);    // 4 2 5 1 3
    postorder(root);  // 4 5 2 3 1
}
```

### 11-3. ë°°ì—´ ê¸°ë°˜ ì´ì§„ íŠ¸ë¦¬ (ì •ì  í• ë‹¹)

```cpp
// ë°°ì—´ë¡œ ì´ì§„ íŠ¸ë¦¬ êµ¬í˜„ (ì™„ì „ ì´ì§„ íŠ¸ë¦¬ì— ìµœì )
// ì¸ë±ìŠ¤ ê´€ê³„: ë¶€ëª¨ i â†’ ì™¼ìª½ ìì‹ 2i, ì˜¤ë¥¸ìª½ ìì‹ 2i+1

const int MAX = 100001;

struct TreeNode {
    int data;
    int left, right;  // ìì‹ ì¸ë±ìŠ¤ (-1ì´ë©´ ì—†ìŒ)
} tree[MAX];

int node_cnt = 0;

// ë…¸ë“œ í• ë‹¹
int alloc(int x) {
    tree[node_cnt].data = x;
    tree[node_cnt].left = -1;
    tree[node_cnt].right = -1;
    return node_cnt++;
}

// ì „ìœ„ ìˆœíšŒ
void preorder(int idx) {
    if (idx == -1) return;
    cout << tree[idx].data << " ";
    preorder(tree[idx].left);
    preorder(tree[idx].right);
}

// ì¤‘ìœ„ ìˆœíšŒ
void inorder(int idx) {
    if (idx == -1) return;
    inorder(tree[idx].left);
    cout << tree[idx].data << " ";
    inorder(tree[idx].right);
}

// í›„ìœ„ ìˆœíšŒ
void postorder(int idx) {
    if (idx == -1) return;
    postorder(tree[idx].left);
    postorder(tree[idx].right);
    cout << tree[idx].data << " ";
}
```

### 11-4. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST) ê¸°ë³¸

```cpp
// ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬: ì™¼ìª½ < ë£¨íŠ¸ < ì˜¤ë¥¸ìª½
struct BSTNode {
    int data;
    BSTNode* left;
    BSTNode* right;
};

BSTNode* root = nullptr;

// ì‚½ì…
BSTNode* insert(BSTNode* node, int x) {
    if (!node) {
        BSTNode* new_node = new BSTNode();
        new_node->data = x;
        new_node->left = new_node->right = nullptr;
        return new_node;
    }
    
    if (x < node->data)
        node->left = insert(node->left, x);
    else if (x > node->data)
        node->right = insert(node->right, x);
    
    return node;
}

// ê²€ìƒ‰
bool search(BSTNode* node, int x) {
    if (!node) return false;
    if (node->data == x) return true;
    if (x < node->data) return search(node->left, x);
    return search(node->right, x);
}

// ì¤‘ìœ„ ìˆœíšŒë¡œ ì •ë ¬ëœ ì¶œë ¥
void inorder(BSTNode* node) {
    if (!node) return;
    inorder(node->left);
    cout << node->data << " ";
    inorder(node->right);
}

// ì‚¬ìš© ì˜ˆì‹œ
int main() {
    root = insert(root, 5);
    insert(root, 3);
    insert(root, 7);
    insert(root, 1);
    insert(root, 4);
    
    //       5
    //      / \
    //     3   7
    //    / \
    //   1   4
    
    inorder(root);  // 1 3 4 5 7 (ì •ë ¬ë¨!)
}
```

### ì¶”ì²œ ë¬¸ì œ (ë¹„ì„ í˜• ìë£Œêµ¬ì¡°)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | êµ¬í˜„ ëŒ€ìƒ |
|------|-----------|----------|----------|
| 1 | 1927 | ìµœì†Œ í™ | í™ êµ¬í˜„ |
| 2 | 11279 | ìµœëŒ€ í™ | í™ êµ¬í˜„ |
| 3 | 11286 | ì ˆëŒ“ê°’ í™ | ì»¤ìŠ¤í…€ í™ |
| 4 | 1991 | íŠ¸ë¦¬ ìˆœíšŒ | ì´ì§„ íŠ¸ë¦¬ |
| 5 | 5639 | ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ | BST |

---

## STEP 12: ê·¸ë˜í”„ ê¸°ì´ˆ

### í•™ìŠµ ëª©í‘œ
- ê·¸ë˜í”„ í‘œí˜„ (ì¸ì ‘ ë¦¬ìŠ¤íŠ¸, ì¸ì ‘ í–‰ë ¬)
- BFS (ë„ˆë¹„ ìš°ì„  íƒìƒ‰)
- DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰)

### í•µì‹¬ ê°œë…

#### ê·¸ë˜í”„ í‘œí˜„
```cpp
int n, m;  // ì •ì  ìˆ˜, ê°„ì„  ìˆ˜

// ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ (ì¶”ì²œ)
vector<int> adj[100001];
for (int i = 0; i < m; i++) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);
    adj[v].push_back(u);  // ë¬´ë°©í–¥
}

// ì¸ì ‘ í–‰ë ¬
int graph[1001][1001];
for (int i = 0; i < m; i++) {
    int u, v;
    cin >> u >> v;
    graph[u][v] = graph[v][u] = 1;
}
```

#### BFS
```cpp
void bfs(int start) {
    queue<int> q;
    bool visited[100001] = {false};
    
    q.push(start);
    visited[start] = true;
    
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        
        cout << cur << " ";
        
        for (int next : adj[cur]) {
            if (!visited[next]) {
                visited[next] = true;
                q.push(next);
            }
        }
    }
}
```

#### DFS
```cpp
bool visited[100001];

void dfs(int cur) {
    visited[cur] = true;
    cout << cur << " ";
    
    for (int next : adj[cur]) {
        if (!visited[next]) {
            dfs(next);
        }
    }
}
```

### ì¶”ì²œ ë¬¸ì œ (ê³¨ë“œ 5~ì‹¤ë²„ 1)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 1260 | DFSì™€ BFS | ê¸°ì´ˆ |
| 2 | 2606 | ë°”ì´ëŸ¬ìŠ¤ | DFS/BFS |
| 3 | 1012 | ìœ ê¸°ë† ë°°ì¶” | ì—°ê²° ìš”ì†Œ |
| 4 | 2178 | ë¯¸ë¡œ íƒìƒ‰ | BFS ìµœë‹¨ê±°ë¦¬ |
| 5 | 7576 | í† ë§ˆí†  | BFS |
| 6 | 2667 | ë‹¨ì§€ë²ˆí˜¸ë¶™ì´ê¸° | DFS/BFS |

---

## STEP 13: ìµœë‹¨ ê²½ë¡œ

### í•™ìŠµ ëª©í‘œ
- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜
- í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜
- ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜

### ì¶”ì²œ ë¬¸ì œ (ê³¨ë“œ 4~5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 1753 | ìµœë‹¨ê²½ë¡œ | ë‹¤ìµìŠ¤íŠ¸ë¼ |
| 2 | 1916 | ìµœì†Œë¹„ìš© êµ¬í•˜ê¸° | ë‹¤ìµìŠ¤íŠ¸ë¼ |
| 3 | 11404 | í”Œë¡œì´ë“œ | í”Œë¡œì´ë“œ |
| 4 | 11403 | ê²½ë¡œ ì°¾ê¸° | í”Œë¡œì´ë“œ |

---

## STEP 14: ë™ì  í”„ë¡œê·¸ë˜ë° (DP)

### í•™ìŠµ ëª©í‘œ
- DPì˜ ê¸°ë³¸ ì›ë¦¬ (ë©”ëª¨ì´ì œì´ì…˜)
- ì í™”ì‹ ì„¸ìš°ê¸°
- Top-down vs Bottom-up

### ì¶”ì²œ ë¬¸ì œ (ì‹¤ë²„ 3~ê³¨ë“œ 5)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 1003 | í”¼ë³´ë‚˜ì¹˜ í•¨ìˆ˜ | DP ê¸°ì´ˆ |
| 2 | 9184 | ì‹ ë‚˜ëŠ” í•¨ìˆ˜ ì‹¤í–‰ | ë©”ëª¨ì´ì œì´ì…˜ |
| 3 | 1463 | 1ë¡œ ë§Œë“¤ê¸° | DP |
| 4 | 11726 | 2Ã—n íƒ€ì¼ë§ | DP |
| 5 | 11727 | 2Ã—n íƒ€ì¼ë§ 2 | DP |
| 6 | 9095 | 1, 2, 3 ë”í•˜ê¸° | DP |
| 7 | 12865 | í‰ë²”í•œ ë°°ë‚­ | ë°°ë‚­ DP |

---

## STEP 15: ë¹„íŠ¸ë§ˆìŠ¤í‚¹ ì‹¬í™” + DP â­

### í•™ìŠµ ëª©í‘œ
- ë¹„íŠ¸ë§ˆìŠ¤í¬ DP
- TSP ë¬¸ì œ ì´í•´
- ìƒíƒœ ì••ì¶• DP

### í•µì‹¬ ê°œë…

#### ë¹„íŠ¸ë§ˆìŠ¤í¬ DP
```cpp
// TSP (ì™¸íŒì› ìˆœíšŒ) - O(nÂ² Ã— 2^n)
int n;
int dist[20][20];
int dp[20][1 << 20];  // dp[í˜„ì¬ìœ„ì¹˜][ë°©ë¬¸ìƒíƒœ]

int tsp(int cur, int visited) {
    // ëª¨ë“  ë„ì‹œ ë°©ë¬¸ ì™„ë£Œ
    if (visited == (1 << n) - 1) {
        return dist[cur][0];  // ì‹œì‘ì ìœ¼ë¡œ ë³µê·€
    }
    
    // ì´ë¯¸ ê³„ì‚°ë¨
    if (dp[cur][visited] != -1) {
        return dp[cur][visited];
    }
    
    int result = INF;
    for (int next = 0; next < n; next++) {
        // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë„ì‹œ
        if (!(visited & (1 << next))) {
            result = min(result, 
                dist[cur][next] + tsp(next, visited | (1 << next)));
        }
    }
    
    return dp[cur][visited] = result;
}
```

### ì¶”ì²œ ë¬¸ì œ (ê³¨ë“œ 1~3)

| ìˆœì„œ | ë¬¸ì œ ë²ˆí˜¸ | ë¬¸ì œ ì œëª© | íƒœê·¸ |
|------|-----------|----------|------|
| 1 | 11723 | ì§‘í•© | ë¹„íŠ¸ë§ˆìŠ¤í¬ ê¸°ì´ˆ |
| 2 | 2098 | ì™¸íŒì› ìˆœíšŒ | ë¹„íŠ¸ë§ˆìŠ¤í¬ DP |
| 3 | 1562 | ê³„ë‹¨ ìˆ˜ | ë¹„íŠ¸ë§ˆìŠ¤í¬ DP |
| 4 | 2533 | ì‚¬íšŒë§ ì„œë¹„ìŠ¤(SNS) | íŠ¸ë¦¬ DP |

---

## ğŸ“Œ í•™ìŠµ íŒ

1. **ë¬¸ì œë¥¼ í’€ê¸° ì „ì— ê°œë…ì„ ë¨¼ì € ì´í•´í•˜ì„¸ìš”**
2. **ì§ì ‘ ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”** - ë³µì‚¬/ë¶™ì—¬ë„£ê¸°ëŠ” í•™ìŠµ íš¨ê³¼ê°€ ë‚®ìŠµë‹ˆë‹¤
3. **ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì½ëŠ” ìŠµê´€ì„ ê¸°ë¥´ì„¸ìš”**
4. **í•œ ë¬¸ì œì— 30ë¶„ ì´ìƒ ë§‰íˆë©´ íŒíŠ¸ë¥¼ ìš”ì²­í•˜ì„¸ìš”**
5. **í’€ì´ í›„ ë‹¤ë¥¸ ì‚¬ëŒì˜ ì½”ë“œë„ ì°¸ê³ í•˜ì„¸ìš”**
6. **STL ì‚¬ìš© ì „ì— ì§ì ‘ êµ¬í˜„í•´ë³´ë©´ ì´í•´ë„ê°€ ë†’ì•„ì§‘ë‹ˆë‹¤**
7. **ì‹œê°„ ë³µì¡ë„ë¥¼ í•­ìƒ ë¨¼ì € ê³„ì‚°í•˜ì„¸ìš”**

---

## ğŸ“Š ë‚œì´ë„ ê°€ì´ë“œ

| í‹°ì–´ | ì˜ˆìƒ í•™ìŠµ ê¸°ê°„ | í•´ë‹¹ STEP |
|------|---------------|----------|
| ë¸Œë¡ ì¦ˆ | 1~2ì£¼ | STEP 0~3 |
| ì‹¤ë²„ | 3~6ì£¼ | STEP 4~9 |
| ê³¨ë“œ | 2~4ê°œì›” | STEP 10~15 |
