# ⚔️ 실전 알고리즘 & 자료구조 커리큘럼

## 📘 개요
이 커리큘럼은 **[바킹독의 실전 알고리즘](https://blog.encrypted.gg/category/%EA%B0%95%EC%A2%8C/%EC%8B%A4%EC%A0%84%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)** 강의 순서를 따릅니다.
C++을 이용한 효율적인 문제 해결(PS) 능력을 기르는 것이 목표입니다.

> **🔗 문제집 링크**: [바킹독 문제집 (GitHub)](https://github.com/encrypted-def/basic-algo-lecture/blob/master/workbook.md)
> 각 챕터 학습 후, 위 링크의 문제들을 순서대로 풀어야 합니다.

---

## 🗺️ 학습 로드맵 (총 2단계 + 심화)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   🧱 FOUNDATION (기초 & 선형 자료구조)                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  0x00 ~ 0x02: 기초 코드 작성요령, 시간/공간복잡도                           │
│  0x03 ~ 0x08: 배열, 연결리스트, 스택, 큐, 덱, 스택 활용(수식)               │
├─────────────────────────────────────────────────────────────────────────────┤
│                   🌲 CORE ALGORITHMS (핵심 알고리즘)                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  0x09 ~ 0x0A: BFS, DFS (그래프 탐색의 기본)                                 │
│  0x0B ~ 0x0C: 재귀(Recursion)와 백트래킹(Backtracking)                      │
│  0x0D ~ 0x10: 시뮬레이션, 정렬, DP(동적계획법)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                   🚀 ADVANCED (심화 & 수학/그래프)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  0x11 ~ 0x15: 그리디, 투 포인터, 이분 탐색, 해시                           │
│  0x16 ~ 0x1D: BST, 우선순위 큐, MST, 다익스트라, 플로이드                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 📋 상세 커리큘럼

### 🧱 FOUNDATION (자료구조의 이해)

#### 0x01 ~ 0x02: 기초
- [ ] **0x01**: 시간복잡도(Big-O), 메모리 제한, 입출력
- [ ] **0x02**: STL vector, string 기초 사용법

#### 0x03 ~ 0x08: 선형 자료구조
> **⚠️ 필수 학습 규칙**: 해당 챕터에서는 **STL 사용이 금지**됩니다.
> 반드시 **배열(Array) 또는 포인터**를 사용하여 기능을 **직접 구현(Implementation)** 해본 뒤에야 STL을 사용할 수 있습니다.
> *예: 연결 리스트의 `insert`, `erase` 기능 직접 짜보기*
- [ ] **0x03 배열(Array)**: 임의 접근(Random Access)과 O(1)
- [ ] **0x04 연결 리스트(Linked List)**: 삽입/삭제 O(1), 야매 연결 리스트(배열 기반) 구현
- [ ] **0x05 스택(Stack)**: 배열로 구현하기, LIFO 구조
- [ ] **0x06 큐(Queue)**: 원형 큐(Circular Queue) 직접 구현, BFS 기초
- [ ] **0x07 덱(Deque)**: 배열/연결리스트로 구현, 양방향 삽입/삭제
- [ ] **0x08 스택의 활용**: 괄호 쌍 맞추기, 수식 계산

---

### 🌲 CORE ALGORITHMS (문제 해결의 핵심)

#### 0x09 ~ 0x0A: 그래프 탐색 (★매우 중요)
> **🤖 Agent's Note**: 2D 맵에서의 캐릭터 이동, 길찾기 AI의 기초가 됩니다.
- [ ] **0x09 BFS(너비 우선 탐색)**: **최단 거리** 구하기 (Flood Fill)
- [ ] **0x0A DFS(깊이 우선 탐색)**: 모든 경우의 수 확인, 미로 찾기

#### 0x0B ~ 0x0C: 완전 탐색
- [ ] **0x0B 재귀(Recursion)**: 귀납적 사고, 하노이 탑
- [ ] **0x0C 백트래킹(Backtracking)**: N-Queen, 상태 트리 탐색

#### 0x0D ~ 0x10: 구현과 최적화
- [ ] **0x0D 시뮬레이션**: 문제 조건 그대로 구현하기 (구현력 필요)
- [ ] **0x0E/0x0F 정렬(Sort)**: Merge Sort, Quick Sort 직접 구현해보기
- [ ] **0x10 다이나믹 프로그래밍(DP)**: 큰 문제를 작은 문제로 나누기, 메모이제이션

---

### 🚀 ADVANCED (고급 기법)

#### 0x11 ~ 0x15: 효율적인 탐색
- [ ] **0x11 그리디(Greedy)**: 매 순간 최적의 선택
- [ ] **0x12 수학**: 소수 판정, 최대공약수
- [ ] **0x13 이분 탐색(Binary Search)**: O(log N) 탐색, Parametric Search
- [ ] **0x14 투 포인터**: O(N)으로 두 개의 지점 조작하기
- [ ] **0x15 해시(Hash)**: O(1) 탐색, 충돌 처리 (`unordered_map`)

#### 0x16 ~ 0x1D: 비선형 자료구조와 그래프
> **🤖 Agent's Note**: 게임 서버의 길찾기, 파티 매칭 시스템 등에 활용됩니다.
- [ ] **0x16 이진 검색 트리(BST)**: `set`, `map`, `multiset`
- [ ] **0x17 우선순위 큐(Heap)**: 최대값/최소값 빠르게 뽑기
- [ ] **0x18 ~ 0x1A 그래프/트리**: 위상 정렬 등
- [ ] **0x1B ~ 0x1D 등 최단 경로**: 다익스트라(Dijkstra), 플로이드(Floyd)

---

## 📝 학습 가이드 (Agent 보충)
1. **문제 풀이 순서**: `기본 문제` → `응용 문제` → `연습 문제` 순으로 진행합니다.
2. **코드 스타일**: PS(Problem Solving)용 코드와 프로덕션(Game Dev)용 코드는 다릅니다. 이 커리큘럼에서는 **빠르고 정확한 구현(PS 스타일)**에 집중하되, 제가 리뷰할 때 유지보수 관점에서의 팁도 함께 드리겠습니다.
3. **오답 노트**: 틀린 문제는 반드시 이유(로직 오류, 범위 초과, 엣지 케이스 등)를 기록하세요.
