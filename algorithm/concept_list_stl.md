# C++ STL: `std::list` 완벽 정리

## 1. 개요 (Overview)
`std::list`는 **이중 연결 리스트(Doubly Linked List)**의 표준 구현체입니다.
앞서 우리가 직접 구현했던 `Node* prev`, `Node* next` 구조를 내부적으로 가지고 있습니다.

### 특징
- **임의 접근 불가 (No Random Access)**: `v[3]` 처럼 인덱스로 접근할 수 없습니다. (`std::vector`와의 차이점)
- **빠른 삽입/삭제**: 반복자(Iterator)만 있으면 중간 삽입/삭제가 **O(1)** 입니다.
- **메모리 오버헤드**: 데이터 외에 포인터 2개(`prev`, `next`)만큼의 추가 공간을 사용합니다.

---

## 2. 주요 API (Cheatsheet)

```cpp
#include <list>
std::list<int> L = {1, 2, 3}; // 초기화
```

### 데이터 조작
| 함수 | 설명 | 시간복잡도 |
| :--- | :--- | :---: |
| `push_front(val)` | 맨 앞에 추가 | O(1) |
| `push_back(val)` | 맨 뒤에 추가 | O(1) |
| `pop_front()` | 맨 앞 제거 | O(1) |
| `pop_back()` | 맨 뒤 제거 | O(1) |
| `item = L.front()` | 맨 앞 원소 참조 | O(1) |
| `item = L.back()` | 맨 뒤 원소 참조 | O(1) |

### 반복자와 위치 조작 (핵심 ⭐)
`std::list`는 인덱스가 없으므로 **Iterator(반복자)**를 커서처럼 사용합니다.

```cpp
auto it = L.begin(); // 시작점 (첫 번째 원소)
it++;                // 오른쪽으로 한 칸 이동
it--;                // 왼쪽으로 한 칸 이동
```

| 함수 | 설명 | 시간복잡도 |
| :--- | :--- | :---: |
| `insert(it, val)` | `it` **앞에** `val` 삽입 | O(1) |
| `erase(it)` | `it`가 가리키는 원소 삭제 | O(1) |

> **꿀팁**: `erase`는 삭제된 원소의 **다음 위치**를 가리키는 Iterator를 반환합니다.
> ```cpp
> it = L.erase(it); // 안전한 삭제 패턴
> ```

---

## 3. `vector` vs `list` 선택 가이드

| 상황 | `std::vector` | `std::list` |
| :--- | :---: | :---: |
| **중간 삽입/삭제가 많다** | ❌ (O(N)) | ✅ (O(1)) |
| **n번째 원소에 바로 접근해야 한다** | ✅ (O(1)) | ❌ (O(N)) |
| **캐시 효율성 (Cache Locality)** | ✅ (메모리 연속) | ❌ (메모리 파편화) |
| **메모리 사용량** | ✅ (적음) | ❌ (많음, 포인터 비용) |

> **실전 팁**: 알고리즘 문제에서 **"커서 이동과 삽입/삭제"**가 주어지면 `list`, 그 외에는 대부분 `vector`가 유리합니다.
