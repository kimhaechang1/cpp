# Module 06-3: 복사 생성자 (Copy Constructor)

## 1. 객체의 복사
C++에서는 객체를 대입하거나 복사할 때 **"복사 생성자"**가 호출되엇습니다.
```cpp
Knight k1("Arthur", 100);
Knight k2 = k1; // 여기서 [복사 생성자]가 호출됩니다!
// Knight k2(k1); 과 똑같은 말입니다.
```

## 2. 얕은 복사 (Shallow Copy)의 함정 🚨
만약 우리가 **복사 생성자를 직접 만들지 않으면**, 컴파일러가 알아서 "기본 복사 생성자"를 만들어줍니다.
이 녀석은 **모든 멤버 변수를 그냥 똑같이 베껴씁니다.**

문제는 멤버 변수 중에 **포인터**가 있을 때 발생합니다.
```cpp
class Pet {
    int* hp; // 포인터 변수!
public:
    Pet() { hp = new int(100); }
    ~Pet() { delete hp; }
};

Pet p1;      // p1.hp가 0x100번지를 가리킴
Pet p2 = p1; // p2.hp도 0x100번지를 가리킴 (주소만 복사!)
```

### 💣 대재앙 (Double Free)
1.  `p1`이 죽을 때 소멸자 호출 -> `0x100`번지 `delete`.
2.  `p2`가 죽을 때 소멸자 호출 -> **이미 지워진 `0x100`번지를 또 `delete` 시도!**
3.  **프로그램 강제 종료 (Crash)** 💥

## 3. 깊은 복사 (Deep Copy)
이 문제를 해결하려면 **"직접" 복사 생성자**를 만들어서,
**"새로운 메모리를 할당하고, 원본의 '값'을 복사해라"**라고 알려줘야 합니다.

```cpp
// 복사 생성자 문법: ClassName(const ClassName& other)
Pet(const Pet& other) {
    // 1. 새로운 메모리 할당
    hp = new int; 
    
    // 2. 원본(other)의 '값'을 복사 (주소 복사 X)
    *hp = *other.hp; 
}
```

이렇게 하면 `p1`과 `p2`는 서로 다른 메모리(`0x100`, `0x200`)를 가지게 되어 안전합니다.

> **Rule of Three (3의 법칙)**: **소멸자**를 직접 만들었다면(뭔가 `delete` 한다는 뜻), **복사 생성자**와 **대입 연산자**도 반드시 직접 만들어야 합니다.
