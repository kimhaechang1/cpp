# Module 06: 클래스와 객체 (Subtitle 1: 기본기)

## 1. 네임스페이스 (Namespace): 이름표 붙이기
협업을 하다 보면 `Monster`라는 이름이 겹칠 수 있습니다. (전투 팀의 Monster, UI 팀의 Monster...)
이때 **"누구네 Monster인지"** 성(Last Name)을 붙여주는 것이 네임스페이스입니다.

```cpp
namespace Battle {
    struct Monster { int hp; };
}

namespace UI {
    struct Monster { int x, y; };
}

int main() {
    Battle::Monster m1; // 전투 팀 몬스터
    UI::Monster m2;     // UI 팀 몬스터
}
```

### 1.1 `using namespace std;`의 진실
*   `std::cou`t은 "Standard(표준) 네임스페이스에 있는 cout"이라는 뜻입니다.
*   `using namespace std;`를 쓰면 `Battle::`, `UI::` 없이 그냥 이름을 부르겠다는 뜻인데, **실무에서는 이름 충돌 위험 때문에 권장하지 않습니다.** (특히 헤더 파일에서는 절대 금지!)
*   **대안**: `using std::cout;` `using std::string;` 처럼 필요한 것만 콕 집어서 여는 것이 좋습니다.

### 1.2 [Q&A] 네임스페이스와 메모리 (중요 ⭐)
**Q1. 네임스페이스는 파일 내 구역을 나누는 건가요?**
*   네, 맞습니다. 하지만 정확히는 "이름(Identifier)의 영역"을 나누는 것입니다.
*   **파일 단위를 넘어서도 존재합니다.** A.cpp와 B.cpp 둘 다 `namespace Game { ... }`을 쓰면, 두 파일의 내용은 같은 `Game` 식구입니다.

**Q2. 함수나 클래스도 넣을 수 있나요?**
*   네! 변수, 함수, 구조체, 클래스, 심지어 **네임스페이스 안에 네임스페이스**(`Game::Network::Packet`)도 가능합니다.

**Q3. 네임스페이스 안의 변수는 메모리 어디에 저장되나요? (정적/스택/힙)**
*   이게 핵심입니다. 네임스페이스 바로 안에 선언된 변수는 **전역 변수(Global Variable)**와 똑같습니다. 즉, **데이터 영역(Static Memory)**에 저장됩니다.
    *   `namespace Game { int hp; }` -> 프로그램 시작부터 끝까지 살아있는 **전역 변수** (`Game::hp`)
*   하지만 네임스페이스 안에 있는 **함수 내부의 변수**는 당연히 **스택(Stack)**입니다.
    *   `namespace Game { void Attack() { int damage = 10; } }` -> `damage`는 **스택**
*   **결론**: 네임스페이스는 **"이름표(Last Name)"**만 붙여줄 뿐, 변수의 선언 위치에 따른 메모리 규칙(전역=데이터, 지역=스택)은 그대로 따릅니다.

**Q4. 두 파일에서 같은 네임스페이스, 같은 변수명을 쓰면 어떻게 되나요? (충돌)**
*   **컴파일 에러(Linker Error)**가 납니다! (ODR 위반: One Definition Rule)
*   A.cpp: `namespace Game { int hp = 100; }`
*   B.cpp: `namespace Game { int hp = 50; }`
*   나중에 **링커(Linker)**가 두 파일을 합칠 때, "어라? `Game::hp`가 두 개네? 어느 걸 써야 해?" 하고 에러를 뱉습니다.
*   **해결책**:
    1.  **`static` 키워드**: `static int hp`라고 쓰면 "이 파일 안에서만 쓸 거야"라는 뜻이 되어 충돌하지 않습니다.
    2.  **무명 네임스페이스**: `namespace { int hp; }` (이름 없는 네임스페이스)를 쓰면 자동으로 `static` 효과를 냅니다.

**Q5. 함수 안에서 네임스페이스를 선언할 수 있나요?**
*   **불가능합니다.** (전역 범위나 다른 네임스페이스 안에서만 가능)
*   함수 안은 "실행되는 로직"의 공간이지, "이름표를 붙이는 설계"의 공간이 아니기 때문입니다.
*   하지만 **`using namespace`**는 함수 안에서도 쓸 수 있습니다! (그 함수 안에서만 유효)

---

## 2. 구조체(`struct`) vs 클래스(`class`)
C++에서 둘은 기능적으로 **99% 똑같습니다.**
단 하나의 차이점은 **"접근 지정자(Access Modifier)의 기본값"**입니다.

### 2.1 접근 지정자 (공개 범위)
*   **`public`**: "누구나 만져도 돼!" (개방)
*   **`private`**: "나(클래스 내부)만 만질 거야!" (폐쇄)

### 2.2 차이점
*   **`struct`**: 기본인 **`public`** (모두 공개) -> 데이터 묶음(DTO) 용도로 주로 사용
*   **`class`**: 기본이 **`private`** (모두 비공개) -> **캡슐화(Encapsulation)**를 통한 설계 용도로 사용

```cpp
struct Data {
    int a; // public (기본값)
};

class Logic {
    int b; // private (기본값) -> 외부에서 접근 불가!
public:
    void SetB(int v) { b = v; } // public 구역을 따로 열어줘야 함
};
```

---

## 3. 왜 `private`을 써야 하나요? (캡슐화의 이유)
**"데이터를 함부로 건드리지 못하게 하고, 반드시 '함수'를 통해서만 조작하게 하기 위해서"**입니다.
이것이 **객체지향 프로그래밍(OOP)**의 시작입니다.

*   **나쁜 예**: `player.hp = -9999;` (외부에서 말도 안 되는 값 대입 가능)
*   **좋은 예**: `player.TakeDamage(9999);` (함수 내부에서 `hp < 0`이면 `0`으로 보정 가능)

> **Agent's Rule**: 앞으로 모든 클래스의 **멤버 변수(데이터)**는 원칙적으로 **`private`**입니다.

---

## 4. 멤버 함수의 선언과 정의 (중요 ⭐)
클래스 안에서 함수를 만들 때는 두 가지 방법이 있습니다.

### 방법 1: 인라인 정의 (Inline Definition) - 간단한 함수용
클래스 안에서 바로 구현부를 작성합니다.
```cpp
class Player {
public:
    void Init() { // 선언과 동시에 정의
        hp = 100;
    }
};
```

### 방법 2: 분리 정의 (Separation) - 복잡한 함수용
클래스 안에는 **"선언(목록)"**만 두고, 구현은 클래스 **밖**으로 뺍니다.
이것을 **"클래스 외부 정의 (Out-of-line Definition)"**라고 부릅니다.
이때 밖에 있는 함수가 "누구네 함수인지" 알려주기 위해 `Player::` (범위 지정 연산자)를 붙여야 합니다.

```cpp
class Player {
public:
    void Init(); // [선언] "나중에 밖에서 만들 거야" (Interface)
};

// [구현] 클래스 밖에서 구현 (반드시 Player::를 붙여야 함)
// 이것이 바로 "구현(Implementation)" 부분입니다.
void Player::Init() {
    hp = 100;
}
```

### 4.1 왜 이렇게 밖으로 빼나요? (인터페이스와 구현의 분리)
이것이 나중에 배울 **헤더 파일(.h)과 소스 파일(.cpp) 분할**의 기초가 됩니다.
*   **클래스 내부(선언)** -> `.h` 파일 (메뉴판: "이런 기능이 있어요")
*   **클래스 외부(구현)** -> `.cpp` 파일 (주방: "실제 요리는 여기서 해요")
*   이렇게 나누면 다른 사람은 **메뉴판(.h)**만 보고도 클래스를 사용할 수 있게 됩니다. (정보 은닉과 협업의 핵심!)

### 4.2 네임스페이스 밖에서 정의하기 (Fully Qualified Name)
만약 `namespace` 블록까지 벗어나서 아예 밖에서 정의하고 싶다면?
"성(Namespace) + 이름(Class) + 함수(Function)"를 다 적어야 합니다.

```cpp
namespace Game {
    class Player {
    public:
        void Dump(); // 선언
    };
} // 네임스페이스 끝

// [O] 올바른 문법: 반환타입 + (네임스페이스::클래스::함수)
void Game::Player::Dump() { 
    // ...
}

// [X] 틀린 문법 (질문하신 내용)
// void::Game::Player Dump() -> 컴파일 에러! (void 뒤에 ::가 오면 안 됨)
```

---

## 5. 범위 지정 연산자 (`::`)의 정체
**`::` (Scope Resolution Operator)**는 네임스페이스 전용이 아닙니다!
**"~의 안에 있는"**이라는 뜻을 가진 모든 곳에 쓰입니다.

*   `Namespace::` (네임스페이스 안에 있는)
*   `Class::` (클래스 안에 있는) -> **질문하신 부분!**
*   `Struct::` (구조체 안에 있는)
*   `Enum::` (열거형 안에 있는)

### 클래스도 하나의 "범위(Scope)"입니다.
`Player` 클래스를 정의한다는 건, **`Player`라는 울타리(Scope)**를 만드는 것과 같습니다.
그래서 밖에서 `Dump`를 부를 때, "그냥 Dump가 아니라 **Player 울타리 안의 Dump**야!"라고 알려주기 위해 `::`를 쓰는 것입니다.

---

## 6. [중요] C++ 객체 생성 vs Java/C#
Java나 C#에서 오신 분들이 가장 충격받는 부분입니다.

### Java의 경우
```java
Player p; // (1) 참조 변수(리모컨)만 만듦. (null 상태)
p = new Player(); // (2) 실제 객체는 힙(Heap)에 만들고 연결해야 함.
```

### C++의 경우 (스택 할당)
```cpp
Player p; // (1) 선언하는 순간, 스택(Stack)에 실제 객체가 "짠!" 하고 생성됩니다.
// 별도의 new가 필요 없습니다.
```
*   **`Player p;`**
    *   메모리(Stack)에 `Player` 크기만큼 공간을 잡고, 바로 사용할 수 있는 **실체**가 됩니다.
    *   이 변수 `p`가 수명을 다하면(함수 끝), 객체도 자동으로 파괴됩니다.
*   **`Player* p = new Player();`**
    *   이게 바로 Java 스타일(참조+힙 할당)과 비슷한 방식입니다. (포인터 변수 + 동적 할당)

> **핵심**: C++에서 `Player p;`는 빈 껍데기가 아니라, 꽉 찬 **실체(Instance)**입니다!
