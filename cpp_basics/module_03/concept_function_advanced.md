# MODULE 03: 함수와 메모리 Part 2 (Advanced)

## 1. 함수 오버로딩 (Function Overloading)
C++의 가장 강력한 기능 중 하나입니다. **"같은 이름의 함수를 여러 개"** 만들 수 있습니다.
단, **매개변수의 개수나 타입**이 달라야 합니다. (반환형만 다른 건 안 됩니다!)

### 1.1. 예시: Attack 함수
```cpp
// 1. 기본 공격
void Attack() {
    cout << "주먹으로 10 데미지!" << endl;
}

// 2. 무기 공격 (매개변수 다름)
void Attack(int weaponDamage) {
    cout << "무기로 " << weaponDamage << " 데미지!" << endl;
}

// 3. 마법 공격 (매개변수 타입 다름)
void Attack(float magicPower) {
    cout << "마법으로 " << magicPower << " 데미지!" << endl;
}
```
컴파일러가 알아서 알맞은 함수를 연결해줍니다.

---

## 2. 디폴트 매개변수 (Default Parameter)
함수 매개변수에 **기본값**을 미리 정해줄 수 있습니다.
호출할 때 값을 안 넣으면, 미리 정해둔 기본값이 들어갑니다.

### 2.1. 사용법과 주의점
```cpp
// 선언부에서 지정합니다.
void Heal(int amount = 10); 

int main() {
    Heal();   // amount = 10 (자동 설정)
    Heal(50); // amount = 50 (덮어쓰기)
}
```

> **⚠️ 주의: 오른쪽 끝부터 채워야 합니다!**
> - `void Func(int a = 1, int b)` (X) - 컴파일 에러!
> - `void Func(int a, int b = 1)` (O) - 가능

---

## 3. 스택 메모리의 비밀 (Stack Memory) ⭐
함수가 호출될 때 컴퓨터 내부에서 무슨 일이 일어날까요?
이것을 이해해야 "메모리 누수"나 "이상한 쓰레기 값" 버그를 잡을 수 있습니다.

### 3.1. 스택 프레임 (Stack Frame)
함수가 호출될 때마다 메모리의 **Stack 영역**에 그 함수만을 위한 전용 공간(방)이 생깁니다.
이 방에는 다음 정보들이 들어갑니다:
1. **매개변수**: 함수에게 전달된 값들
2. **지역 변수**: 함수 안에서 선언된 변수들 (`int temp` 등)
3. **반환 주소**: 함수가 끝나면 돌아갈 코드의 위치

### 3.2. 생명 주기 (Life Cycle)
가장 중요한 점은 **"함수가 끝나면( `}`를 만나면) 스택 프레임이 통째로 날아간다"**는 것입니다.

```cpp
// ⚠️ 경고: 절대 따라하지 마세요!
int& DangerousFunction() {
    int localVal = 100; // 스택에 생성됨
    return localVal;    // ⚠️ 위험! 사라질 변수의 '참조(별명)'를 리턴함
}

int main() {
    int& ref = DangerousFunction();
    // ref가 가리키는 localVal은 이미 메모리에서 사라졌습니다.
    // cout << ref; // 실행하면 쓰레기 값이 나오거나 프로그램이 터집니다.
}
```

> **핵심**: 지역 변수의 참조(`&`)를 리턴하면 절대 안 됩니다! (방 뺀 친구의 집 주소를 가지고 있는 것과 같습니다.)

---

---

## 4. Q&A: 심화 질문 정리

### 4.1. Java vs C++ 오버로딩 차이점
Java의 오버로딩에 익숙하시다면, C++은 **90% 비슷하지만 더 강력(하고 위험)**합니다.

**1) 디폴트 매개변수와의 충돌 (C++ 고유 문제)**
`void Func(int a)`와 `void Func(int a, int b=5)`가 같이 있으면, `Func(10)` 호출 시 컴파일러가 헷갈려합니다. (모호성 에러)

**2) `const`와 참조에 의한 오버로딩**
C++은 `const` 여부나 `&`(참조) 여부로도 함수를 구분합니다. (Java는 불가능)

```cpp
void Draw(int& num)       { cout << "수정 가능한 숫자"; }
void Draw(const int& num) { cout << "읽기 전용 숫자"; }
```

### 4.2. 참조(`&`) vs 포인터(`*`) 문법 완전 정복
사용자 질문: *"결국 `int& a = &b` 처럼 받아서 바로 값을 쓰는 편의성인가요?"*

**정확합니다! (단, 문법이 살짝 다릅니다)**
사용자님의 직관대로 **"참조는 포인터의 편의성 버전"**이 맞습니다. 내부적으로는 주소를 다루니까요.
하지만 C++ 문법에서는 **"참조 변수를 만들 때는 주소 연산자(`&`)를 안 쓴다"**는 규칙이 있습니다.

| 구분 | 포인터 (`*`) | 참조자 (`&`) |
| :--- | :--- | :--- |
| **선언** | `int* p = &a;` | `int& r = a;` (주소(&) 안 붙임!) |
| **의미** | "나는 a의 **주소**를 담겠다." | "나는 a의 **별명**이 되겠다." |
| **사용** | `*p = 10;` (직접 열어야 함) | `r = 10;` (자동으로 열림) |
| **비유** | 사물함 열쇠 | 스페어 키 (그냥 쓰면 됨) |

> **핵심 요약**:
> - `int* p = &a;` 👉 주소를 담으려면 `&`를 붙여야 함.
> - `int& r = a;` 👉 별명이 되려면 그냥 변수를 넣어야 함. (내부적으로 알아서 주소 가져감)

### 4.3. 참조(`int&`)를 반환한다는 것의 의미 (심화)
사용자 질문: *"저러면 localVal의 시작 주소를 반환하는 건가요?"*

맞습니다! C++ 내부적으로 **참조(Reference)**는 **포인터(Pointer)**와 거의 똑같이 작동합니다.
- **문법적 의미**: "이 변수의 **별명**을 줄게." (Alias)
- **기계적 의미**: "이 변수의 **메모리 주소**를 줄게." (Address)

```cpp
int& ReturnsRef() {
    int local = 10;
    return local; // 실제로는 local의 '주소'가 리턴됨
}

int main() {
    int& ref = ReturnsRef(); 
    // ref는 내부적으로 ReturnsRef가 던져준 '주소'를 가리키게 됨.
    // 하지만 그 주소(local의 방)는 함수가 끝나면서 이미 폐기처분됨.
    // 결론: ref는 '유령의 집'을 가리키게 됨 (Dangling Reference)
}
```

그래서 **지역 변수**는 절대 참조로 리턴하면 안 되지만,
**전역 변수**나 **맴버 변수**처럼 함수가 끝나도 살아있는 녀석들은 `int&`로 리턴해서 원본을 수정하게 만들기도 합니다.

### 4.4. 왜 `*` (포인터)가 아니라 `&` (참조)로 받나요?
사용자 질문: *"주소를 반환한 거면 `*` 포인터 변수로 받아야 하지 않나요?"*

**C++이 해주는 가장 큰 서비스(마법)**가 바로 이 부분입니다!

- **포인터 (`int* p`)**: "나는 **주소**를 저장하는 변수야. 내용물을 보려면 `*p`라고 해." (수동)
- **참조 (`int& r`)**: "나는 **주소**를 받지만, 쓸 때는 마치 **원본 그 자체인 척** 할게." (자동)

컴파일러는 `int&`를 보면 내부적으로 주소를 받아서 연결해두고, 사용할 때마다 **몰래 `*`를 붙여서(Dereference)** 값을 꺼내줍니다.
그래서 프로그래머가 `*`를 붙일 필요가 없는 것이죠. (이것을 Syntactic Sugar라고 합니다.)

```cpp
int* p = &a; // 주소를 직접 담음
*p = 20;     // "주소로 가서" 20을 넣어라 (수동)

int& r = a;  // 주소를 받지만 'a'인 척 함
r = 20;      // "그냥 넣어" (컴파일러가 "주소로 가서 넣기"로 바꿔줌)
```
