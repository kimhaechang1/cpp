# MODULE 04: 함수 포인터 (Function Pointer)

## 1. 개요: 코드를 가리키는 손가락
지금까지 배운 포인터는 **데이터(변수)**가 어디 있는지 가리켰습니다.
그런데 생각해보면, **함수(Function)**도 컴파일되면 메모리 어딘가에 바이너리 코드로 저장되지 않을까요?

네, 맞습니다! **코드 영역(Code Segment)**에 저장됩니다.
따라서, **"코드가 시작되는 주소"**를 가리키는 포인터도 만들 수 있습니다.

이것이 바로 **함수 포인터**입니다.

---

## 2. 왜 필요한가요?
게임 개발에서 함수 포인터(또는 이를 감싼 `std::function`, 델리게이트)는 필수입니다.

1.  **콜백(Callback)**: "공격 버튼을 누르면 → `Attack` 함수를 실행해줘"라고 연결할 때.
2.  **상태 머신(FSM)**: "걷는 상태면 `Walk()`, 뛰는 상태면 `Run()`을 실행해"라고 상태에 따라 행동을 갈아끼울 때.
3.  **UI 시스템**: "버튼 A를 누르면 `OnOpenWindow()` 실행해"

---

## 3. 문법 (Syntax)
함수 포인터 문법은 처음 보면 조금 무섭게 생겼습니다. 하지만 **"반환값"과 "매개변수"**만 잘 맞추면 됩니다.

### 3.1. 선언 방법
```cpp
// 1. 대상 함수
int Add(int a, int b) { return a + b; }

// 2. 함수 포인터 선언
// (반환형) (*포인터이름)(매개변수들);
int (*funcPtr)(int, int); 

// 3. 주소 대입 및 사용
funcPtr = Add;       // 함수 이름이 곧 주소입니다 (배열처럼!)
int result = funcPtr(10, 20); // Add(10, 20)과 똑같이 동작
```

### 3.2. 주의할 점 (괄호)
괄호를 빼먹으면 전혀 다른 뜻이 됩니다.

- `int (*f)(int)` : int를 반환하는 함수의 **포인터** (O -> 우리가 원하는 것)
- `int *f(int)` : int 포인터(`int*`)를 반환하는 **함수** (X -> 그냥 함수 선언)

### 4. Q&A: 괄호의 마법
**Q. `int* f(int)`는 그러면 새로운 함수를 만드는(선언하는) 건가요?**
**A. 네, 정확합니다!**

컴퓨터는 이 둘을 "연산자 우선순위"로 구분합니다.
1.  **`int *f(int)`**:
    - `f(int)`가 먼저 해석됨 -> "f는 함수구나!"
    - 그 다음 `int*`가 붙음 -> "반환값이 int 포인터구나!"
    - 결론: **함수 선언 (Function Declaration)**

2.  **`int (*f)(int)`**:
    - `(*f)`가 괄호로 묶여서 가장 먼저 해석됨 -> "f는 포인터구나!"
    - 그 다음 `(int)`가 붙음 -> "함수를 가리키는 포인터구나!"
    - 결론: **변수 선언 (Variable Declaration)**

**Q. `void Add(int a, int b)`랑 `int* f(int)`는 그럼 같은 건가요?**
**A. 네! 구조적으로 완전히 똑같습니다.**

둘 다 **"함수를 만드는(선언하는) 행위"**입니다.
단지 반환하는 **타입(Return Type)**만 다를 뿐입니다.

- `void Add(int a, int b)` : 아무것도 안 돌려주는 함수
- `int Sum(int a, int b)` : 정수(`int`)를 돌려주는 함수
- `int* f(int a)` : 정수의 주소(`int*`)를 돌려주는 함수

**반면, `int (*f)(int)`는 함수를 만드는 게 아니라, "주소를 담을 변수"를 만드는 것입니다.**

### Q. `int* f(int, int)`를 매개변수로 받으면 어떻게 되나요?
**A. `int* (*f)(int, int)` (함수 포인터)로 자동 변환됩니다!**

배열을 매개변수로 받으면 포인터로 변하듯이(`int[]` -> `int*`), 함수도 매개변수 자리에서는 **함수 포인터로 자동 변환(Decay)**됩니다.
즉, **"주소를 리턴하는 함수"를 인자로 받겠다**는 뜻입니다.

```cpp
// 아래 두 코드는 100% 동일합니다.
void Battle( int* f(int, int) );       // (1) 함수 타입으로 씀
void Battle( int* (*f)(int, int) );    // (2) 실제로는 포인터로 처리됨
```

### Q. 함수 안에서 만든 변수의 주소를 리턴해도 되나요?
**A. 절대 안 됩니다! (Dangling Pointer)**

```cpp
int* Dangerous() {
    int a = 10;
    return &a; // (X) 함수 끝나면 'a'는 사라짐!
}
```
함수가 종료되면 지역 변수(`a`)는 스택에서 삭제됩니다. 사라진 메모리 주소를 들고 있으면 프로그램이 터집니다.
반드시 **전역 변수**, **Heap(동적 할당)**, 또는 **매개변수로 받은 주소**만 리턴해야 합니다.

---

## 5. 모던 C++ 스타일 (`std::function`)
생짜 함수 포인터(`int (*)(int, int)`)는 문법이 너무 복잡해서, 모던 C++에서는 `std::function`을 제공합니다. (나중에 더 깊게 배울 예정이지만 미리 구경만 해봅시다.)

```cpp
#include <functional>

function<int(int, int)> f = Add; // 훨씬 읽기 쉽죠?
```
하지만 **기본 원리(주소를 찾아가서 실행한다)**를 이해하기 위해, 우리는 생짜 포인터로 먼저 연습할 것입니다.

---

다음 단계에서는 **테스트 주도 개발(TDD) 스타일**로 직접 함수 포인터를 사용해보는 실습을 진행하겠습니다.
제가 미리 만들어둔 `main` 함수의 테스트를 통과하도록, 여러분이 함수를 구현해주시면 됩니다!
