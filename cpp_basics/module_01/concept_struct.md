# C++ 기초: Struct (구조체)

## 1. Struct (구조체)의 메모리 구조

### 📏 Padding (패딩)과 Alignment (정렬)
CPU는 데이터를 효율적으로 읽기 위해 **한 번에 'Word' 단위(32bit=4byte, 64bit=8byte)로** 읽는 것을 좋아합니다.

하지만 **무조건 4/8바이트가 되는 것은 아닙니다!**
구조체의 전체 크기는 **"가장 큰 멤버 변수의 배수(Word Multiple)"**로 맞춰집니다. (예: `double`이 있으면 8의 배수, `int`만 있으면 4의 배수)

### 💣 선언 순서가 중요한 이유 (Packing)
멤버 배치를 대충 하면, 사이사이에 빈 공간(Padding)이 엄청나게 생겨서 메모리를 낭비하게 됩니다.

```cpp
// ❌ [나쁜 예] 징검다리 배치 (총 24바이트)
// 1칸(char) + 7칸(낭비) + 8칸(double) + 1칸(char) + 7칸(낭비)
struct BadStruct {
    char a;     // [a][ ][ ][ ][ ][ ][ ][ ] (0~7)  <- 1바이트 쓰고 7바이트 버림
    double b;   // [b][b][b][b][b][b][b][b] (8~15) <- 8바이트 (꽉 참)
    char c;     // [c][ ][ ][ ][ ][ ][ ][ ] (16~23) <- 1바이트 쓰고 7바이트 버림
};

// ⭕ [좋은 예] 큰 것부터 내림차순 배치 (총 16바이트)
// 8칸(double) + 2칸(char 2개) + 6칸(낭비)
struct GoodStruct {
    double b;   // [b][b][b][b][b][b][b][b] (0~7)  <- 8바이트 (꽉 참)
    char a;     // [a][c][ ][ ][ ][ ][ ][ ] (8~15) <- 남은 공간에 옹기종기 모임
    char c;     
};
```
> **팁**: **"큰 덩어리(double, int)부터 먼저 선언하고, 작은 것(char)을 뒤에 몰아넣는다"**라고 기억하면 편합니다!

> **🤔 왜 이런 현상이 발생하나요?**
> CPU가 메모리 버스(Bus)를 통해 데이터를 가져오는 물리적인 원리 때문입니다.
> *이 내용은 **[STEP 2.5: CS 기초 - OS와 컴퓨터 구조]** 챕터에서 아주 자세히 다룰 예정입니다! (지금은 "줄 맞춤"이 성능에 좋다는 것만 기억하세요)*

### 🔬 눈으로 확인하기 (sizeof)
백문이 불여일견! `sizeof` 연산자를 쓰면 실제 크기를 바이트 단위로 알려줍니다.

```cpp
cout << "Player Size: " << sizeof(Player) << " bytes" << endl;
```

### 🙋‍♂️ Q&A: "포인터로 크기(Size)를 잴 때 주의점"

> **Q. `Player* p`가 있을 때, 실제 데이터 크기를 알고 싶으면 `sizeof(p)`를 하면 되나요?**
>
> **결론**: 부족하면 터지고, 과하면 낭비됩니다. **`sizeof(Type)`으로 "딱 맞게" 빌리는 것이 정답입니다.**

---

## 4. Struct와 Vector의 만남 (반복문)

### 🏃‍♂️ 범위 기반 for문 (Range-based for loop)
구조체가 담긴 벡터를 돌 때는 **국룰 패턴**이 있습니다.

```cpp
vector<Player> party;
// ... (데이터 추가) ...

// [추천 패턴] const auto&
for (const auto& p : party) {
    // p.hp = 0; // ❌ 수정 불가능 (const 안전장치)
    cout << p.name << endl; // ⭕ 읽기 가능
}
```

### 🙋‍♂️ Q&A: "왜 `const auto&`를 쓰나요?"

> 1.  **`auto`**: `Player`라고 길게 쓰기 귀찮아서 (컴파일러가 알아서 맞춰줌)
> 2.  **`&` (참조)**: **"복사하지 마!"** (이게 없으면 루프 돌 때마다 구조체가 통째로 복사돼서 엄청 느려짐)
> 3.  **`const` (상수)**: **"건드리지 마!"** (단순히 출력만 할 건데 실수로 데이터를 바꾸는 사고를 방지)

### 🙋‍♂️ Q&A: "왜 `cout << p` 가 안 되나요?"
> **컴퓨터**: "p가 뭔데? 이름을 찍어? HP를 찍어? 나는 몰라!"
> 
> 기본타입(`int`, `double`)은 출력법이 정해져 있지만, **사용자 정의 타입(Struct)**은 컴퓨터가 출력 방법을 모릅니다.
> -> 귀찮더라도 **멤버를 하나씩 지정해서** 출력해야 합니다.
> *   `cout << p.name << " " << p.hp;` (⭕ 정답)

> *   `sizeof(p)`: **포인터 변수 자체의 크기** (무조건 8바이트)
> *   `sizeof(*p)`: **포인터가 가리키는 대상(Target)**의 크기 (구조체 크기)
> *   `sizeof(&p)`: 포인터 변수의 주소 (이중 포인터 크기, 8바이트)
>
> ```cpp
> Player* p = new Player();
> 
> cout << sizeof(p);  // 8 (주소 크기)
> cout << sizeof(*p); // 16 (Player 구조체 크기) - 정답! 🎯
> ```
> **주의**: `malloc`으로 동적 할당한 "배열"의 크기(예: 100개짜리)는 `sizeof`로 알 수 없습니다. 그건 프로그래머가 따로 기억해야 합니다.

### 🙋‍♂️ Q&A: "string(40)이 있는데 왜 전체는 48인가요?"

> **Q. `sizeof(name)`이 40인데, `int(4) + enum(4)` 하면 딱 48 아닌가요? 패딩이 없나요?**
>
> **A. 네, 운 좋게 딱 맞았습니다! (Perfect Packing)**
>
> 1.  `string name` (40바이트): 40은 8(가장 큰 멤버의 기준)의 배수이므로 **OK**.
> 2.  `int hp` (4바이트) + `enum element` (4바이트) = **8바이트**.
> 3.  **총합 = 40 + 8 = 48바이트**.
>     *   빈 공간(패딩) 없이 8바이트 블록 6개로 꽉 찼습니다.
>     *   만약 `element`를 뺐다면? -> `40 + 4 = 44` -> 8의 배수여야 하므로 **패딩 4바이트**가 붙어서 **여전히 48바이트**였을 겁니다.

### 🙋‍♂️ Q&A: "구조체(Struct)에 생성자가 있나요?"

> **Q. `Character(...)` 처럼 함수 쓰듯이 초기화하던데, 구조체도 그런 게 되나요?**
>
> **A. 네! 사실 C++에서 `struct`는 `class`와 99% 똑같습니다.**
>
> *   C언어 시절 `struct`: 데이터만 담는 **가방**. (생성자 불가)
> *   C++의 `struct`: 데이터 + 기능(함수)을 담는 **로봇**. (생성자 가능!)
>
> 다만, 생성자(Constructor)나 메서드 같은 **"객체 지향 문법"**은 내용이 방대하여 **[Module 06: 클래스와 객체]**에서 아주 깊게 다룰 예정입니다.
> 지금은 **"C++ 구조체는 이름만 빼고 클래스랑 똑같다"** 정도로만 알아두시면 충분합니다! 😄

### 🧠 [핵심 요약] 포인터 문법 해석 공식
헷갈릴 때는 이 말을 기억하세요!

1.  **`p` (그냥 변수명)**
    *   **"내용물"**: 주소값 (예: 100번지)
    *   **비유**: "100호실 열쇠"가 들어있는 상자
2.  **`*p` (별표)**
    *   **"따라가기(Dereference)"**: 그 주소로 **이동해!**
    *   **비유**: 100호실 문을 열고 들어감 -> **방 안의 실체(Player)**를 만남
3.  **`&p` (앤퍼센트)**
    *   **"주소 구하기(Address of)"**: 이 변수(상자) 자체가 놓인 위치
    *   **비유**: 열쇠가 들어있는 **상자의 위치** (예: 내 주머니 속)

### 🙋‍♂️ Q&A: "string은 글자 수만큼 커지나요?"

> **Q. `string name = "A";`랑 `string name = "ABCDE...";`랑 sizeof 크기가 다른가요?**
>
> **A. 아니요! 둘 다 똑같습니다. (약 32~40 바이트)**
>
> `std::string`도 결국 구조체(클래스)입니다. 내부에는 대략 이런 정보들만 들어있습니다.
> 1.  **포인터**: 실제 글자가 저장된 힙(Heap) 주소 (8바이트)
> 2.  **Size**: 현재 글자 수 (8바이트)
> 3.  **Capacity**: 최대 용량 (8바이트)
> 4.  **SSO 버퍼**: 짧은 문자열 최적화용 여분 공간
>
> 실질적인 **"긴 문자열 데이터"**는 힙(Heap)에 저장되고, `string` 변수 자체는 **"그 힙을 관리하는 관리자"**일 뿐이라서 크기가 고정되어 있습니다.
> (즉, `Member` 구조체 안에 `string`이 있어도 구조체 크기는 변하지 않습니다!)

---

## 2. Struct 심화 사용법

### 🏹 구조체 포인터 (Pointer to Struct)
구조체도 변수이므로 주소를 가질 수 있습니다.
포인터로 접근할 때는 점(`.`) 대신 **화살표(`->`) 연산자**를 사용합니다!

```cpp
Player hero = {"Hero", 100};
Player* pHero = &hero;

// 점(.) 사용: (*pHero).hp = 90; // 불편함
// 화살표(->) 사용: pHero->hp = 90; // 편함! (국룰)
```

### 🏷️ 별칭 붙이기 (typedef vs using)

**"이건 `int`형이야"** 라고 이름을 붙여주는 기능입니다.

1.  **typedef (옛날 방식)**: `typedef int* IntPtr;`
    *   C언어 시절부터 쓰던 방식입니다.
    *   변수 선언과 모양이 비슷해서, 긴 코드 사이에서 "이게 새로운 타입 정의인지, 변수 선언인지" 헷갈릴 때가 있습니다.
    
2.  **using (최신 방식)**: `using IntPtr = int*;`
    *   C++11부터 도입되었습니다.
    *   **"왼쪽(새 이름) = 오른쪽(원래 타입)"** 형태로 대입 연산자(`=`)를 쓰기 때문에, "아, 이거 별칭 만드는 거구나!"라고 직관적으로 알 수 있습니다.
    *   나중에 배울 '템플릿' 같은 고급 기능과도 궁합이 좋아서, 요즘은 **무조건 `using`을 쓰는 추세**입니다.

---

## 3. 핵심 질문: 포인터에 왜 타입이 필요할까요?

> **"주소값은 다 똑같은 크기(64비트 기준 8바이트)인데, 왜 `void*`가 아니라 `Player*`라고 타입을 정해줘야 할까요?"**

정말 날카로운 질문입니다! 주소 자체는 그냥 숫자 하나가 맞습니다.
하지만 컴퓨터가 그 주소로 찾아갔을 때 **"거기서부터 얼만큼 읽어야 하는지"**를 알아야 하기 때문입니다.

### 🏠 비유: 택배 기사님
*   **주소**: "서울시 강남구 테헤란로 123번지"
*   **타입**: "거기 가서 **[편지 봉투]**를 가져와" vs "**[냉장고]**를 가져와"

1.  **크기(Size)를 알기 위해**:
    *   `char* p`: "이 주소에서 **1바이트**만 읽어라"
    *   `int* p`: "이 주소에서 **4바이트**를 읽어라"
    *   `Player* p`: "이 주소에서 **Player 크기(예: 8바이트)**만큼 덩어리로 읽어라"

2.  **해석(Interpretation)을 위해**:
    *   `Player*`라고 알려줘야, `p->hp`라고 했을 때 "아, 시작 주소에서 4칸 건너뛰면 hp가 있구나!"라고 **내부 구조**를 이해하고 찾아갈 수 있습니다.
    *   만약 그냥 주소만 있다면 내부의 `hp`가 어디 있는지 알 방법이 없습니다.

> **🤯 심화 질문: "그 구조(메타데이터)는 대체 누가 기억하나요?"**
>
> **정답: "아무도 기억하지 않습니다. 컴파일러가 '계산'해서 숫자로 바꿔버립니다."**
>
> 1.  **포인터 `p`**: 오직 **"시작 주소 (예: 100번지)"** 하나만 기억합니다.
> 2.  **구조체 `Player`**: "hp는 시작점에서 4칸 뒤에 있고, 크기는 4바이트야"라는 **지도(Offset 정보)** 역할을 합니다.
>
> **[p->hp 의 처리 과정]**
> *   작성 코드: `p->hp`
> *   컴파일러의 생각:
>     1.  `p`의 시작 주소는? -> **100번지** (라고 가정)
>     2.  `hp`는 어디 있지? -> `Player` 지도를 보니 **+4 바이트** 떨어져 있네.
>     3.  얼만큼 읽어야 하지? -> `hp`는 `int`니까 **4 바이트**를 읽자.
> *   최종 기계어: **"주소 (100 + 4)번지로 가서 4바이트를 읽어와!"**
>
> 즉, 실행될 때는 "구조체"라는 개념은 사라지고 **"시작 주소 + 거리(Offset)"** 계산만 남게 됩니다.

### 📍 [시각화] 메모리 접근 시뮬레이션
```
[메모리 지도]
0x1000 : [ p (시작점) ] 
0x1000 : [ rank (1byte) ] 
0x1001 : [ padding ...  ]
0x1004 : [ hp (4bytes)  ] <--- 목표 지점
```

1.  `p`는 **0x1000 (시작 주소)**만 꽉 쥐고 있습니다.
2.  `p->hp`를 하면?
    *   **위치 계산**: 시작점(0x1000) + 떨어진 거리(4) = **0x1004**
    *   **데이터 획득**: 거기서 **4바이트** 만큼 쑥 뽑아냅니다.
```

---

## 4. 동적 할당 (Dynamic Allocation)

### 🆚 일반 변수 vs 포인터 변수 (중요 ⭐)

```cpp
// 1. 일반 변수 (Stack)
Player p1; 
p1.hp = 100;

// 2. 포인터 변수 (Heap + Dynamic)
Player* p2 = new Player();
p2->hp = 100;
```

### 특징 비교

**1. 일반 변수 (`Player p`)**
*   **생성 위치**: **스택(Stack)** (함수가 끝나면 자동으로 삭제됩니다.)
*   **크기**: 구조체 전체 크기를 차지합니다. (예: 100바이트면 100바이트)
*   **복사 비용**: **비쌈** (함수에 넘겨줄 때 내용물이 전부 복사됩니다.)
*   **접근법**: 점 (`.`)을 사용합니다.

**2. 포인터 변수 (`Player* p`)**
*   **생성 위치**: **힙(Heap)** (내가 원할 때 만들고, 원할 때 삭제합니다.)
*   **크기**: 주소 크기만 차지합니다. (무조건 **8바이트**)
*   **복사 비용**: **저렴** (주소 8바이트만 복사하면 끝입니다.)
*   **접근법**: 화살표 (`->`)를 사용합니다.

### 🛠️ C 스타일: malloc 심화

**1. 초기화 방법 (전통적 방식)**
`malloc`은 생성자를 호출하지 않기 때문에, 직접 값을 채워줘야 합니다.

> **Q. 왜 `(Player*)`로 캐스팅을 하나요?**
> *   `malloc`은 자기가 뭘 빌려주는지 모릅니다. 그냥 **"메모리 덩어리(void*)"**를 줄 뿐입니다.
> *   그래서 **"야, 이거 Player 용이야!"**라고 딱지에 써붙여(Casting) 줘야 컴파일러가 알아먹습니다. (C++은 타입에 엄격하거든요)

```cpp
// (Player*) <- 이게 없으면 에러남! (void* -> Player* 변환 불가)
Player* p1 = (Player*)malloc(sizeof(Player)); 

// 방법 A: 하나씩 대입 (귀찮음)
p1->hp = 100;
// 방법 B: 0으로 싹 밀어버리기 (memset)
memset(p1, 0, sizeof(Player)); 
```
> **🤔 "0으로 민다"는 게 무슨 뜻인가요?**
> *   **의미**: 해당 메모리 블록의 **모든 비트(Bit)**를 0으로 채웁니다. (`00000000...`)
> *   **주의 (매우 중요 🚨)**: `int` 같은 기본 타입은 괜찮지만, **`std::string` 같은 C++ 객체를 0으로 밀면 망가집니다!** (절대 금지)

**2. 💣 메모리를 부족하게 할당하면? (Under-allocation)**
*   `malloc(4)` 했는데 8바이트를 쓰면 -> **Heap Corruption(메모리 오염)** 발생!

**3. 🐷 메모리를 과하게 할당하면? (Over-allocation)**
*   `malloc(100)` 했는데 8바이트만 쓰면 -> **메모리 낭비(Leak)** 및 **단편화(Fragmentation)** 발생!

### 🏥 [디버깅 클리닉] 자주 겪는 3대 실수

### 🏥 [디버깅 클리닉] 왜 내 코드는 터질까요? (코드로 보는 해설)

**1. "malloc 했는데 왜 NULL 포인터라고 하죠?"**
```cpp
BadStruct* bad = (BadStruct*)malloc(sizeof(BadStruct));
cout << bad->a << endl; // ⚠️ Warning: Dereferencing NULL pointer 'bad'
```
*   **이유**: `malloc`은 메모리가 꽉 차면 실패해서 `NULL(0)`을 반환할 수 있습니다.
*   **경고**: 똑똑한 컴파일러(Visual Studio)가 **"야, 너 `malloc`이 실패했을 때 검사 안 했잖아! 만약 NULL이면 어쩔 건데?"** 라고 혼내는 것입니다. (실제로는 메모리가 충분하면 안 터지지만, 안전을 위한 잔소리입니다.)

**2. "hero1->name 출력하는데 왜 터져요?"**
```cpp
Character* hero1 = (Character*)malloc(sizeof(Character));
cout << hero1->name << endl; // ❌ 쾅! (Runtime Error)
```
*   **이유**: `malloc`은 **"생성자(Constructor)"를 실행하지 않습니다.**
*   `hero1`은 할당되었지만, 그 안의 `string name`은 초기화되지 않은 **쓰레기값** 상태입니다.
*   `cout`이 `name`을 출력하려고 내부를 들여다보는 순간, 엉뚱한 주소를 참조해서 프로그램이 죽습니다.
*   **해결**: `bad`는 단순 데이터(`char`, `double`)라 괜찮았지만, `string` 같은 객체는 반드시 **`new`**로 만들어야 합니다.

**3. "memset(hero2...)는 왜 안 돼요?"**
```cpp
Character* hero2 = (Character*)memset(hero2, 0, sizeof(hero2)); // ❌ 
```
*   **상황**: `hero2` 변수를 선언하는 순간입니다. 아직 `hero2`에는 **아무 주소도 없습니다(Garbage).**
*   **비유**: "청소부(`memset`) 아저씨, **(아직 안 산 집)** 주소로 가서 청소해주세요."
*   **결과**: 청소부가 이상한 주소(쓰레기값)로 찾아가서 물청소를 하다가 경찰(OS)한테 잡혀갑니다.
*   **해결**: `malloc`으로 집을 먼저 사고(주소를 받고), 그 다음에 `memset`을 불러야 합니다.
