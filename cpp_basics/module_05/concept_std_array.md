# Module 05 보충: `std::array` - C 배열의 완벽한 상위호환 🛡️

## 1. C 스타일 배열(`int arr[5]`)의 문제점
우리가 지금까지 썼던 `int arr[5];`는 사실 **C언어의 유산**입니다.
이 녀석은 치명적인 단점들이 있습니다.

1.  **길이 정보를 잃어버림 (Decay)**: 함수로 넘기면 포인터가 되어 `size()`를 알 수 없음. (방금 배웠죠?)
2.  **대입 불가**: `arr1 = arr2;` 이렇게 통째로 복사가 안 됨.
3.  **범위 체크 안 함**: `arr[100]`에 접근해도 컴파일러가 모를 수 있음.

---

## 2. 해결책: `std::array` (Stack Memory)
`std::array`는 **"스택에 사는 배열"**입니다.
`std::vector`는 힙(Heap)에 살아서 느리지만, `std::array`는 C 배열과 속도가 **100% 똑같으면서도**,
C++ 클래스의 장점(Member Function, Iterator 등)을 모두 가집니다.

### 2.1 선언 방법
```cpp
#include <array>

// [Old]
int oldArr[5] = {1, 2, 3, 4, 5};

// [Modern] <타입, 크기>
std::array<int, 5> newArr = {1, 2, 3, 4, 5};
```

### 2.2 장점
1.  **크기를 항상 기억함**: `.size()` 함수 제공.
2.  **대입 가능**: 구조체처럼 통째로 복사 가능! (`arr2 = arr1;`)
3.  **반복자 지원**: `std::sort`, `std::find` 등 STL 알고리즘 사용 가능.
4.  **안전한 접근(옵션)**: `.at(i)`를 쓰면 범위를 벗어날 때 에러를 뿜어줌(예외 발생).

---

## 3. 언제 `vector` 쓰고 언제 `array` 쓰나요?
*   크기가 **변한다** (추가/삭제) -> **`std::vector`** (Heap)
*   크기가 **고정이다** (불변) -> **`std::array`** (Stack)
*   **그냥 C 배열(`[]`)은?** -> **이제 쓰지 마세요.** (하위 호환성을 위해 남겨둔 것일 뿐)

### 💡 Agent's Tip
실무에서는 **고정 크기 버퍼(Buffer)**나 **테이블(Lookup Table)**을 만들 때 `std::array`를 정말 많이 씁니다.
성능 손해 0 + 안전성 확보 = 안 쓸 이유가 없죠!

---

## 4. 핵심 Q&A (Learner's Questions)

### Q1. `std::array` 대입 시, 얕은 복사(주소 복사)인가요? 깊은 복사(값 복사)인가요?
> **A. 100% 깊은 복사(Deep Copy)입니다.**
> *   `std::array<int, 5> a = b;`를 하면 `b`의 모든 원소가 `a`의 새로운 메모리 공간으로 복사됩니다.
> *   C 스타일 배열(`int a[5] = b;`)은 컴파일 에러가 나지만, `std::array`는 안전하게 값을 복제해줍니다.

### Q2. `std::array`는 스택(Stack)에만 저장되나요? 힙(Heap)은 안 쓰나요?
> **A. 네, `std::array` 타입 자체는 힙을 전혀 사용하지 않습니다.**
> *   `std::array` 내부에는 `T data[N];` 형태의 정적 배열만 존재합니다.
> *   `std::vector`는 껍데기만 스택에 있고 알맹이는 힙에 있지만, `std::array`는 껍데기와 알맹이가 한 몸입니다.
> *   단, `new std::array<int, 5>` 처럼 동적 할당을 하면, **`std::array` 객체 전체가 힙에 생성**됩니다.

### Q3. 다른 함수로 전달할 때 복사 비용이 크지 않을까요?
> **A. 맞습니다. 그래서 꼭 `const &` (참조)로 전달해야 합니다.**
> *   `void Func(std::array<int, 10000> arr)` -> 40KB 복사 발생 (느려짐)
> *   `void Func(const std::array<int, 10000>& arr)` -> 주소만 전달 (빠름)
> *   함수가 리턴되기 전까지는 스택 메모리가 유효하므로, 참조나 포인터로 전달해도 안전합니다.
