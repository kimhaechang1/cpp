# Module 05: 포인터와 메모리 (동적 할당)

## 1. 스택(Stack) vs 힙(Heap) 메모리

프로그램이 사용하는 메모리는 크게 두 가지 영역으로 나뉩니다.

### 1.1 스택 (Stack)
- **특징**: 함수 호출 시 생성되고, 함수가 끝나면 **자동으로 소멸**됩니다.
- **장점**: 관리가 매우 빠르고 편리합니다.
- **단점**: 크기가 작고, 수명(Live Time)을 제어할 수 없습니다. (함수 끝나면 무조건 죽음)
- **비유**: 식당의 "접시" (손님이 오면 꺼내주고, 가면 바로 설거지통으로)

### 1.2 힙 (Heap)
- **특징**: 프로그래머가 **원하는 시점에 만들고, 원하는 시점에 없앨 수** 있습니다.
- **장점**: 수명을 마음대로 조정할 수 있고, 큰 메모리도 사용 가능합니다.
- **단점**: **직접 해제(delete)** 하지 않으면 메모리에 계속 남아있습니다. (이게 바로 **메모리 누수**)
- **비유**: 창고의 "자재" (내가 꺼내오고 싶을 때 꺼내고, 다 쓰면 다시 갖다놔야 함. 안 갖다 놓으면 창고가 꽉 참)

---

## 2. new와 delete 연산자

C++에서는 `malloc/free` (C언어) 대신 `new/new[]`와 `delete/delete[]`를 사용합니다.
생성자/소멸자를 호출해주기 때문입니다.

### 2.1 단일 변수 할당
```cpp
// 할당 (Heap에 int 방 하나 만들기)
int* p = new int;      // 쓰레기값 초기화
int* p2 = new int(10); // 10으로 초기화

// 사용 (Pointer와 동일)
*p = 20;

// 해제 (다 썼으면 반드시 반납)
delete p;
delete p2;
```

### 2.2 배열 할당
배열을 할당할 때는 `[]`를 사용해야 합니다. 해제할 때도 반드시 `delete[]`를 써야 합니다.
```cpp
// 할당 (Heap에 int 방 10개짜리 배열 만들기)
int size;
std::cin >> size; // 런타임에 크기 결정 가능! (스택 배열은 불가능)

int* arr = new int[size]; 

// 사용
for(int i=0; i<size; ++i) {
    arr[i] = i * 10;
}

// 해제 (배열은 delete[] 필수)
delete[] arr; 
```

> **⚠️ 주의**: `new`로 만들고 `delete[]` 하거나, `new[]`로 만들고 `delete` 하면 **정의되지 않은 동작(Undefined Behavior)** 발생!

---

## 3. 메모리 누수 (Memory Leak)

빌린 돈을 안 갚으면 신용불량자가 되듯이, 빌린 메모리를 안 갚으면(`delete` 안 함) 컴퓨터 메모리가 부족해집니다.
특히 게임처럼 오래 켜두는 프로그램에서는 치명적입니다.

### 3.1 댕글링 포인터 (Dangling Pointer) 방지
메모리를 해제학 나면 포인터 변수에는 여전히 "해제된 주소"가 남아있습니다.
안전을 위해 `nullptr`을 대입해주는 것이 좋습니다.

```cpp
delete p;
p = nullptr; // 안전장치
```

---

## 4. 실습: 동적 할당과 메모리 누수 탐지

Visual Studio(MSVC) 환경에서는 `_CrtSetDbgFlag`를 통해 프로그램 종료 시 누수를 탐지할 수 있습니다.

```cpp
// practice_dynamic.cpp 템플릿 예시
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>
#include <iostream>

int main() {
    // 프로그램 종료 시 메모리 누수 정보를 출력하도록 설정
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

    // 1. int형 변수 동적 할당 실습
    // TODO: 여기에 작성
    
    // 2. 크기를 입력받아 배열 동적 할당 실습
    // TODO: 여기에 작성


    return 0;
}
```

---

## 5. 심화: 변수 위치에 따른 메모리 영역 (Memory Layout)
변수가 "어디에 선언되었느냐"에 따라 사는 곳(메모리 영역)이 완전히 다릅니다.

### 5.1 전역 변수 (Data 영역)
- **위치**: 함수 바깥에 선언된 변수
- **수명**: 프로그램 시작부터 종료까지
- **특징**: `data`(초기화된 변수) 또는 `bss`(초기화 안 된 변수) 영역에 저장됩니다. (힙도 스택도 아닙니다!)

### 5.2 지역 변수 (Stack 영역)
- **위치**: 함수 내부 `{ ... }` 안에 선언된 변수
- **수명**: `{` 에서 태어나서 `}` 만나면 죽음
- **특징**: 크기가 컴파일 타임에 정해져야 합니다. (변수 크기 변경 불가)

### 5.3 동적 변수 (Heap 영역)
- **위치**: `new` 연산자로 만들어진 녀석들
- **수명**: `delete` 할 때까지
- **특징**: "포인터 변수 자체"는 스택에 있지만, "포인터가 가리키는 실제 데이터"는 힙에 있습니다.

```cpp
int g_data = 10; // [Data 영역] (전역변수)

void Func() {
    int  n = 10;          // [Stack 영역] (지역변수)
    int* p = new int(20); // p는 [Stack], *p(실제 20)는 [Heap]
} // 여기서 n과 p는 사라지지만, *p(Heap에 있는 20)는 남음 -> 메모리 누수!
```

---

## 6. 정적 배열 vs 동적 배열 (Q&A)

### Q1. `int arr[]`와 `new int[]`의 차이는?
| 구분 | 정적 배열 (`int arr[10]`) | 동적 배열 (`new int[n]`) |
|------|---------------------------|--------------------------|
| **메모리** | **Stack** (지역변수일 때) | **Heap** |
| **크기 결정** | **컴파일 타임** (무조건 상수여야 함) | **런타임** (변수로 크기 지정 가능) |
| **수명** | 함수 끝나면 자동 소멸 | `delete[]`전까지 영구 보존 |
| **크기 제한** | 작음 (보통 1MB 정도) | 큼 (시스템 메모리 허용까지) |

> **핵심**: "사용자가 몇 명 입력할지 모를 때"는 무조건 **동적 할당**을 써야 합니다. 스택 배열은 `int arr[n]`처럼 변수로 크기를 정할 수 없습니다.
