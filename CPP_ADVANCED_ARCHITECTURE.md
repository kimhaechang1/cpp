# C++ 심화 & 아키텍처 커리큘럼

## 🏰 개요
**"모든 문법을 안다고 해서 좋은 프로그램을 만들 수 있는 것은 아닙니다."**
이 커리큘럼은 C++ 언어 기초를 넘어, **대규모 소프트웨어(게임 엔진, 서버)**를 견고하고 빠르게 만들기 위한 **설계와 최적화**를 다룹니다.

---

## 🗺️ 학습 로드맵 (총 4단계)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       🏛️ DESIGN PATTERNS (설계 패턴)                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  MODULE 1: 생성 패턴 (Singleton, Factory, Builder)                          │
│  MODULE 2: 구조/행동 패턴 (Observer, Strategy, Component)                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                       ⚡ PERFORMANCE & MEMORY (성능 최적화)                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  MODULE 3: 메모리 모델과 캐시 (Cache Locality, Data Oriented)               │
│  MODULE 4: 커스텀 메모리 관리 (Object Pool, Memory Arena)                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                       🔄 CONCURRENCY (동시성 프로그래밍)                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  MODULE 5: 멀티스레딩 기초 (Thread, Mutex, Deadlock)                        │
│  MODULE 6: 동기화와 원자성 (Atomic, Lock-free 기초)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                       ⚙️ ENGINE ARCHITECTURE (엔진 아키텍처)                │
├─────────────────────────────────────────────────────────────────────────────┤
│  MODULE 7: ECS (Entity Component System) 패턴 이해                          │
│  MODULE 8: 이벤트 시스템과 메시지 큐                                        │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 📋 상세 커리큘럼

### 🏛️ DESIGN PATTERNS (게임 개발 필수 패턴)
> 문법이 "벽돌"이라면, 패턴은 "벽돌 쌓는 법"입니다.

#### MODULE 1: 생성 패턴
- [ ] **Singleton**: 관리자(Manager) 클래스에 필수 (하지만 남용 금지!)
- [ ] **Factory**: 몬스터/아이템 생성을 캡슐화하기
- [ ] **Builder**: 복잡한 객체(맵, 캐릭터) 단계별 생성

#### MODULE 2: 주요 게임 패턴
- [ ] **Component Pattern**: 상속의 한계를 넘어서는 조립식 설계 (Unity/Unreal 방식)
- [ ] **Observer Pattern**: "HP가 0이 되면" → UI 업데이트, 사운드 재생 알림
- [ ] **State Pattern**: FSM(유한 상태 머신) 구현의 정석

> **🔥 ADVANCED PROJECT 1: 컴포넌트 기반 액터 시스템**
> - 상속 없이 `Transform`, `Renderer`, `Physics` 컴포넌트를 조립하여 게임 오브젝트 만들기

---

### ⚡ PERFORMANCE & MEMORY
> C++을 쓰는 이유 = 속도. 하드웨어를 이해하고 최적화합니다.

#### MODULE 3: 하드웨어 친화적 코딩
- [ ] **Cache Locality**: Linked List가 왜 느린가? (배열 vs 리스트)
- [ ] **Data Oriented Design (DOD)**: 객체 지향(OOP)의 성능 한계와 대안

#### MODULE 4: 메모리 풀링
- [ ] **Object Pool**: 총알 수백 개를 `new/delete` 없이 재사용하기
- [ ] **Memory Alignment**: 데이터 정렬과 패딩

> **🔥 ADVANCED PROJECT 2: 고성능 총알 관리자 (Object Pool)**
> - 수천 개의 총알을 프레임 드랍 없이 생성하고 회수하는 시스템 구현

---

### 🔄 CONCURRENCY (멀티스레딩)
> 요즘 CPU는 코어가 많습니다. 하나만 쓰면 손해입니다.

#### MODULE 5: 스레드 기초
- [ ] **std::thread**: 로딩 화면에서 리소스 비동기 로딩하기
- [ ] **Race Condition**: 두 스레드가 하나의 변수를 건드릴 때 생기는 문제
- [ ] **Mutex & Lock**: 데이터 보호하기

#### MODULE 6: 고급 동기화
- [ ] **Atomic**: 락 없이 안전하게 변수 조작하기

---

### ⚙️ ENGINE ARCHITECTURE
> 진짜 "상용 엔진"들이 작동하는 방식입니다.

#### MODULE 7: ECS 아키텍처
- [ ]Entity(ID), Component(Data), System(Logic)의 분리
- [ ]유니티 DOTS나 오버워치 엔진이 사용하는 최신 아키텍처 맛보기

> **🔥 FINAL PROJECT: 미니 멀티스레드 ECS 엔진**
> - 데이터(Component)와 로직(System)을 분리하여 초고속으로 엔티티 업데이트하기
